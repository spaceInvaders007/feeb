I:",
              error?.message || error
            );
          }
        }
        console.log("🔍 -------------------------");
      }
      Alert.alert(
        "Debug Info",
        `Found ${
          (await FeebStorage.getAllFeebs()).length
        } feebs. Check console.`
      );
    } catch (error: any) {
      console.error("🔍 Error in debug:", error);
      Alert.alert("Debug Error", error?.message || "Unknown error");
    }
    console.log("🔍 ======= FEEB DEBUG END =======");
  };

  useFocusEffect(
    useCallback(() => {
      loadUserFeebs();
    }, [])
  );

  const loadUserFeebs = async () => {
    try {
      setLoading(true);
      const feebs = await FeebStorage.getAllFeebs();
      setUserFeebs(feebs);
      await loadFeebDisplayUris(feebs);
    } catch (error: any) {
      console.error("Error loading feebs:", error);
      Alert.alert("Error", error?.message || "Failed to load your feebs");
    } finally {
      setLoading(false);
    }
  };

  const loadFeebDisplayUris = async (feebs: Feeb[]) => {
    try {
      const displayStates = await Promise.all(
        feebs.map(async (feeb) => {
          const state: FeebItemState = {
            id: feeb.id,
            displayUri: feeb.uri,
            loading: false,
            error: false,
          };
          if (Platform.OS === "web" && feeb.isWebBlob) {
            state.loading = true;
            const displayUri = await FeebStorage.getFeebDisplayUri(feeb);
            state.loading = false;
            if (displayUri) {
              state.displayUri = displayUri;
            } else {
              state.error = true;
              state.displayUri = "";
            }
          }
          return state;
        })
      );
      setFeebDisplayStates(displayStates);
    } catch (error: any) {
      console.error("Error loading display URIs:", error);
      Alert.alert("Error", error?.message || "Failed to load videos");
    }
  };

  const getFeebDisplayState = (feebId: string) =>
    feebDisplayStates.find((s) => s.id === feebId);

  const handlePlayFeeb = async (feeb: Feeb) => {
    try {
      let playableUri = feeb.uri;
      if (Platform.OS === "web" && feeb.isWebBlob) {
        const st = getFeebDisplayState(feeb.id);
        playableUri =
          st?.displayUri || (await FeebStorage.getFeebDisplayUri(feeb));
      }
      if (!playableUri) {
        Alert.alert("Error", "Video could not be loaded");
        return;
      }
      setFullscreenFeeb({ ...feeb, displayUri: playableUri });
    } catch (error: any) {
      console.error("Error playing feeb:", error);
      Alert.alert("Error", error?.message || "Failed to play video");
    }
  };

  const handleDeleteFeeb = (feebId: string) =>
    Alert.alert("Delete Feeb", "Are you sure?", [
      { text: "Cancel", style: "cancel" },
      {
        text: "Delete",
        style: "destructive",
        onPress: async () => {
          try {
            await FeebStorage.deleteFeeb(feebId);
            await loadUserFeebs();
            Alert.alert("Success", "Feeb deleted");
          } catch (error: any) {
            console.error("Error deleting feeb:", error);
            Alert.alert("Error", error?.message || "Failed to delete feeb");
          }
        },
      },
    ]);

  const handleCleanupInvalidFeebs = () =>
    Alert.alert(
      "Clean Up Invalid Videos",
      "This will remove feebs that cannot be displayed. Continue?",
      [
        { text: "Cancel", style: "cancel" },
        {
          text: "Clean Up",
          style: "destructive",
          onPress: async () => {
            try {
              const invalid = feebDisplayStates
                .filter((s) => s.error)
                .map((s) => s.id);
              for (const id of invalid) {
                await FeebStorage.deleteFeeb(id);
              }
              await loadUserFeebs();
              Alert.alert("Success", `Removed ${invalid.length} items`);
            } catch (error: any) {
              console.error("Error cleaning up:", error);
              Alert.alert("Error", error?.message || "Failed to clean up");
            }
          },
        },
      ]
    );

  const renderFeebItem = ({ item }: { item: Feeb }) => (
    <FeebVideoGridItem
      feeb={item}
      displayState={getFeebDisplayState(item.id)}
      onPress={() => handlePlayFeeb(item)}
      onLongPress={() => handleDeleteFeeb(item.id)}
    />
  );

  const renderContentItem = ({ item }: { item: ContentItem }) => (
    <View style={styles.gridItem}>
      <Image source={{ uri: item.uri }} style={styles.gridImage} />
      <View style={styles.playIcon}>
        <Ionicons name="play-circle" size={24} color="white" />
      </View>
    </View>
  );

  const renderHeader = () => (
    <View style={styles.headerContainer}>
      <Text style={styles.title}>My profile</Text>
      <Image source={{ uri: user.avatarUri }} style={styles.avatar} />
      <Text style={styles.name}>{user.name}</Text>
      <Text style={styles.handle}>{user.handle}</Text>
      <View style={styles.statsRow}>
        {[
          { label: "Followers", value: user.followers },
          { label: "Following", value: user.following },
          { label: "Feebs", value: String(userFeebs.length) },
        ].map((s) => (
          <View key={s.label} style={styles.stat}>
            <Text style={styles.statValue}>{s.value}</Text>
            <Text style={styles.statLabel}>{s.label}</Text>
          </View>
        ))}
      </View>
      <TouchableOpacity style={styles.editButton}>
        <Text style={styles.editButtonText}>Edit profile</Text>
        <Ionicons name="pencil" size={20} color="#00CFFF" />
      </TouchableOpacity>
      <TouchableOpacity style={styles.debugButton} onPress={debugFeebFiles}>
        <Text style={styles.debugButtonText}>Debug Feebs</Text>
        <Ionicons name="bug" size={20} color="#FF6B6B" />
      </TouchableOpacity>
      {Platform.OS === "web" && feebDisplayStates.some((s) => s.error) && (
        <TouchableOpacity
          style={styles.cleanupButton}
          onPress={handleCleanupInvalidFeebs}
        >
          <Text style={styles.cleanupButtonText}>Clean up invalid videos</Text>
          <Ionicons name="trash" size={16} color="#ff6b6b" />
        </TouchableOpacity>
      )}
      <View style={styles.tabRow}>
        {(["Feebs", "Contents"] as const).map((tab) => (
          <TouchableOpacity
            key={tab}
            style={styles.tabButton}
            onPress={() => setActiveTab(tab)}
          >
            <Text
              style={[
                styles.tabText,
                activeTab === tab && styles.tabTextActive,
              ]}
            >
              {tab}
              {tab === "Feebs" && ` (${userFeebs.length})`}
            </Text>
          </TouchableOpacity>
        ))}
      </View>
      <View style={styles.dividerRow}>
        <View
          style={[
            styles.divider,
            activeTab === "Feebs" && styles.dividerActive,
          ]}
        />
        <View
          style={[
            styles.divider,
            activeTab === "Contents" && styles.dividerActive,
          ]}
        />
      </View>
    </View>
  );

  const renderEmptyState = () => (
    <View style={styles.emptyState}>
      <Ionicons name="videocam-outline" size={64} color="#ccc" />
      <Text style={styles.emptyTitle}>No feebs yet</Text>
      <Text style={styles.emptySubtitle}>
        Record your first reaction to get started!
      </Text>
    </View>
  );

  if (loading && activeTab === "Feebs") {
    return (
      <View style={styles.loadingContainer}>
        <Text>Loading your feebs...</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      {activeTab === "Feebs" ? (
        <FlatList
          data={userFeebs}
          keyExtractor={(item) => item.id}
          numColumns={COLUMN_COUNT}
          showsVerticalScrollIndicator={false}
          contentContainerStyle={styles.listContent}
          ListHeaderComponent={renderHeader}
          ListEmptyComponent={renderEmptyState}
          renderItem={renderFeebItem}
        />
      ) : (
        <FlatList
          data={sampleContents}
          keyExtractor={(item) => item.id}
          numColumns={COLUMN_COUNT}
          showsVerticalScrollIndicator={false}
          contentContainerStyle={styles.listContent}
          ListHeaderComponent={renderHeader}
          renderItem={renderContentItem}
        />
      )}
      <FullscreenVideoModal
        visible={!!fullscreenFeeb}
        feeb={fullscreenFeeb}
        onClose={() => setFullscreenFeeb(null)}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  /* ... your existing styles unchanged ... */
  container: { flex: 1, backgroundColor: "#fff" },
  listContent: { padding: SPACING, backgroundColor: "#fff" },
  headerContainer: { padding: SPACING, paddingBottom: SPACING * 2 },
  title: { fontSize: 28, fontWeight: "700" },
  avatar: {
    width: 96,
    height: 96,
    borderRadius: 48,
    alignSelf: "center",
    marginTop: SPACING,
  },
  name: {
    fontSize: 22,
    fontWeight: "600",
    textAlign: "center",
    marginTop: SPACING / 2,
  },
  handle: {
    fontSize: 14,
    color: "#888",
    textAlign: "center",
    marginBottom: SPACING,
  },
  statsRow: {
    flexDirection: "row",
    justifyContent: "space-around",
    marginBottom: SPACING,
  },
  stat: { alignItems: "center" },
  statValue: { fontSize: 18, fontWeight: "600" },
  statLabel: { fontSize: 12, color: "#aaa" },
  editButton: {
    flexDirection: "row",
    alignSelf: "center",
    alignItems: "center",
    borderWidth: 1,
    borderColor: "#00CFFF",
    borderRadius: 24,
    paddingHorizontal: 16,
    paddingVertical: 8,
    marginBottom: SPACING * 2,
  },
  editButtonText: {
    color: "#00CFFF",
    fontSize: 16,
    fontWeight: "600",
    marginRight: 8,
  },
  debugButton: {
    flexDirection: "row",
    alignSelf: "center",
    alignItems: "center",
    borderWidth: 1,
    borderColor: "#FF6B6B",
    borderRadius: 24,
    paddingHorizontal: 16,
    paddingVertical: 8,
    marginBottom: SPACING * 2,
    backgroundColor: "rgba(255, 107, 107, 0.1)",
  },
  debugButtonText: {
    color: "#FF6B6B",
    fontSize: 16,
    fontWeight: "600",
    marginRight: 8,
  },
  cleanupButton: {
    flexDirection: "row",
    alignSelf: "center",
    alignItems: "center",
    borderWidth: 1,
    borderColor: "#ff6b6b",
    borderRadius: 16,
    paddingHorizontal: 12,
    paddingVertical: 6,
    marginBottom: SPACING,
  },
  cleanupButtonText: {
    color: "#ff6b6b",
    fontSize: 12,
    fontWeight: "600",
    marginRight: 6,
  },
  tabRow: {
    flexDirection: "row",
    justifyContent: "space-around",
    marginBottom: SPACING / 2,
  },
  tabButton: { flex: 1, alignItems: "center", paddingVertical: 8 },
  tabText: { fontSize: 16, color: "#888" },
  tabTextActive: { color: "#000", fontWeight: "700" },
  dividerRow: { flexDirection: "row", height: 2, marginBottom: SPACING * 1.5 },
  divider: { flex: 1, backgroundColor: "transparent" },
  dividerActive: { backgroundColor: "#000" },
  gridItem: {
    width: ITEM_SIZE,
    height: ITEM_SIZE,
    margin: SPACING / 2,
    borderRadius: 12,
    overflow: "hidden",
    backgroundColor: "#f0f0f0",
    position: "relative",
  },
  gridImage: { width: "100%", height: "100%" },
  videoContainer: { width: "100%", height: "100%", backgroundColor: "#000" },
  gridVideoWeb: { width: "100%", height: "100%", objectFit: "cover" },
  videoPlaceholder: {
    width: "100%",
    height: "100%",
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "#1a1a1a",
  },
  videoPlaceholderText: { color: "#888", fontSize: 12, marginTop: 8 },
  playButtonOverlay: {
    position: "absolute",
    top: "50%",
    left: "50%",
    transform: [{ translateX: -20 }, { translateY: -20 }],
  },
  playButtonCircle: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: "rgba(0, 207, 255, 0.9)",
    justifyContent: "center",
    alignItems: "center",
  },
  videoInfoOverlay: { position: "absolute", bottom: 4, left: 4, right: 4 },
  videoTypeIcon: {
    position: "absolute",
    top: 4,
    left: 4,
    backgroundColor: "rgba(0, 207, 255, 0.8)",
    borderRadius: 8,
    padding: 2,
  },
  videoDate: {
    color: "white",
    fontSize: 10,
    textShadowColor: "rgba(0, 0, 0, 0.7)",
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 2,
  },
  videoPlatform: {
    color: "white",
    fontSize: 8,
    opacity: 0.8,
    textShadowColor: "rgba(0, 0, 0, 0.7)",
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 2,
  },
  playIcon: { position: "absolute", top: 8, right: 8 },
  loadingItem: {
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "#f0f0f0",
  },
  loadingText: { color: "#666", fontSize: 12 },
  errorItem: {
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "#ffebee",
  },
  errorText: {
    color: "#d32f2f",
    fontSize: 10,
    marginTop: 4,
    textAlign: "center",
    fontWeight: "bold",
  },
  errorSubtext: {
    color: "#d32f2f",
    fontSize: 8,
    marginTop: 2,
    textAlign: "center",
    opacity: 0.8,
  },
  emptyState: {
    alignItems: "center",
    justifyContent: "center",
    paddingVertical: 40,
  },
  emptyTitle: { fontSize: 18, fontWeight: "600", color: "#666", marginTop: 16 },
  emptySubtitle: {
    fontSize: 14,
    color: "#aaa",
    textAlign: "center",
    marginTop: 8,
    paddingHorizontal: 32,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "#fff",
  },
});


// File: src/screens/ChatsScreen.tsx
import { View, Text, FlatList, StyleSheet, Image } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

const chats = [
  {
    id: '1',
    name: 'Floyd Miles',
    message: 'You have to see that feeb pleaaaase open it 😂',
    time: '1 min ago',
    avatar: 'https://randomuser.me/api/portraits/men/1.jpg',
  },
  {
    id: '2',
    name: 'Kristin Watson',
    message: '📽️ Sent you a feeb',
    time: '8:24 p.m.',
    avatar: 'https://randomuser.me/api/portraits/women/2.jpg',
  },
  {
    id: '3',
    name: 'Ralph Edwards',
    message: 'Ok!',
    time: '4:34 p.m.',
    avatar: 'https://randomuser.me/api/portraits/men/3.jpg',
  },
];

export default function ChatsScreen() {
  return (
    <View style={{ flex: 1, backgroundColor: '#fff' }}>
      <Text style={styles.title}>Chats</Text>
      <FlatList
        data={chats}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => (
          <View style={styles.item}>
            <Image source={{ uri: item.avatar }} style={styles.avatar} />
            <View style={{ flex: 1 }}>
              <Text style={styles.name}>{item.name}</Text>
              <Text style={styles.message}>{item.message}</Text>
            </View>
            <View style={styles.meta}>
              <Text style={styles.time}>{item.time}</Text>
              <Ionicons name="chevron-forward" size={18} color="#aaa" />
            </View>
          </View>
        )}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  title: {
    fontSize: 28,
    fontWeight: '700',
    marginTop: 50,
    marginBottom: 20,
    marginLeft: 20,
  },
  item: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    borderBottomColor: '#eee',
    borderBottomWidth: 1,
  },
  avatar: {
    width: 50,
    height: 50,
    borderRadius: 25,
    marginRight: 12,
  },
  name: {
    fontWeight: '600',
    fontSize: 16,
  },
  message: {
    color: '#666',
  },
  time: {
    fontSize: 12,
    color: '#aaa',
    marginBottom: 4,
  },
  meta: {
    alignItems: 'flex-end',
    justifyContent: 'center',
  },
});

// File: src/utils/FeebStorage.ts
import AsyncStorage from '@react-native-async-storage/async-storage';
import * as FileSystem from 'expo-file-system';
import { Platform } from 'react-native';

export interface Feeb {
  id: string;
  uri: string; // Local file path or persistent data URL for web
  originalVideoUri: string; // The video they reacted to
  createdAt: string;
  thumbnail?: string; // Optional thumbnail
  isWebBlob?: boolean; // Flag to indicate if it's a web blob (now converted to data URL)
}

const FEEBS_STORAGE_KEY = 'user_feebs';
const WEB_VIDEO_STORAGE_KEY = 'web_video_data_';

export class FeebStorage {
  // Get all user's feebs
  static async getAllFeebs(): Promise<Feeb[]> {
    try {
      const feebsJson = await AsyncStorage.getItem(FEEBS_STORAGE_KEY);
      const feebs = feebsJson ? JSON.parse(feebsJson) : [];
      
      // Clean up any old blob URLs automatically
      if (Platform.OS === 'web') {
        const cleanedFeebs = feebs.filter((feeb: Feeb) => {
          if (feeb.isWebBlob && feeb.uri.startsWith('blob:')) {
            console.log('🧹 Automatically removing feeb with expired blob URL:', feeb.id);
            return false;
          }
          return true;
        });
        
        // If we removed any feebs, save the cleaned list
        if (cleanedFeebs.length !== feebs.length) {
          await AsyncStorage.setItem(FEEBS_STORAGE_KEY, JSON.stringify(cleanedFeebs));
          console.log(`🧹 Cleaned up ${feebs.length - cleanedFeebs.length} feebs with expired blob URLs`);
        }
        
        return cleanedFeebs;
      }
      
      return feebs;
    } catch (error) {
      console.error('Error loading feebs:', error);
      return [];
    }
  }

  // Save a new feeb
  static async saveFeeb(feeb: Feeb): Promise<void> {
    try {
      const existingFeebs = await this.getAllFeebs();
      const updatedFeebs = [feeb, ...existingFeebs]; // Add new feeb at the beginning
      await AsyncStorage.setItem(FEEBS_STORAGE_KEY, JSON.stringify(updatedFeebs));
      console.log('✅ Feeb saved successfully:', feeb.id);
    } catch (error) {
      console.error('Error saving feeb:', error);
      throw error;
    }
  }

  // Web-specific: Save video blob to persistent storage
  static async saveWebVideoBlob(blob: Blob): Promise<string> {
    try {
      console.log('🌐 Converting blob to persistent storage...');
      console.log('📊 Blob info:', { size: blob.size, type: blob.type });
      
      // Convert blob to data URL for persistence
      const dataUrl = await new Promise<string>((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          console.log('📖 FileReader completed');
          resolve(reader.result as string);
        };
        reader.onerror = (error) => {
          console.error('❌ FileReader error:', error);
          reject(error);
        };
        reader.readAsDataURL(blob);
        console.log('📖 Starting FileReader...');
      });

      console.log('✅ Data URL created, length:', dataUrl.length);

      // Generate unique ID for this video
      const videoId = `feeb_video_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      console.log('🆔 Generated video ID:', videoId);
      
      // Store the data URL in AsyncStorage with a unique key
      const storageKey = WEB_VIDEO_STORAGE_KEY + videoId;
      console.log('💾 Storing with key:', storageKey);
      
      // For large data URLs, we might need to chunk them
      const chunkSize = 1000000; // 1MB chunks
      if (dataUrl.length > chunkSize) {
        console.log('📦 Large data URL detected, chunking...');
        const chunks = [];
        for (let i = 0; i < dataUrl.length; i += chunkSize) {
          chunks.push(dataUrl.substring(i, i + chunkSize));
        }
        
        // Store chunk count first
        await AsyncStorage.setItem(`${storageKey}_chunks`, chunks.length.toString());
        
        // Store each chunk
        for (let i = 0; i < chunks.length; i++) {
          await AsyncStorage.setItem(`${storageKey}_chunk_${i}`, chunks[i]);
        }
        
        console.log(`💾 Stored ${chunks.length} chunks for video:`, videoId);
      } else {
        await AsyncStorage.setItem(storageKey, dataUrl);
        console.log('💾 Stored single data URL for video:', videoId);
      }
      
      console.log('💾 Web video saved to persistent storage:', videoId);
      console.log('📊 Data URL size:', Math.round(dataUrl.length / 1024), 'KB');
      
      // Return the video ID as the persistent URI
      return videoId;
    } catch (error) {
      console.error('❌ Error saving web video blob:', error);
      throw error;
    }
  }

  // Web-specific: Retrieve video data URL from storage
  static async getWebVideoDataUrl(videoId: string): Promise<string | null> {
    try {
      const storageKey = WEB_VIDEO_STORAGE_KEY + videoId;
      
      // Check if it's chunked
      const chunkCountStr = await AsyncStorage.getItem(`${storageKey}_chunks`);
      
      if (chunkCountStr) {
        // Reassemble from chunks
        const chunkCount = parseInt(chunkCountStr, 10);
        console.log(`📦 Reassembling ${chunkCount} chunks for video:`, videoId);
        
        const chunks = [];
        for (let i = 0; i < chunkCount; i++) {
          const chunk = await AsyncStorage.getItem(`${storageKey}_chunk_${i}`);
          if (chunk) {
            chunks.push(chunk);
          } else {
            console.error(`❌ Missing chunk ${i} for video:`, videoId);
            return null;
          }
        }
        
        const dataUrl = chunks.join('');
        console.log('✅ Retrieved chunked web video data URL for:', videoId);
        return dataUrl;
      } else {
        // Single data URL
        const dataUrl = await AsyncStorage.getItem(storageKey);
        if (dataUrl) {
          console.log('✅ Retrieved web video data URL for:', videoId);
          return dataUrl;
        } else {
          console.log('❌ No data URL found for video ID:', videoId);
          return null;
        }
      }
    } catch (error) {
      console.error('❌ Error retrieving web video:', error);
      return null;
    }
  }

  // Save recorded video to permanent location (platform-specific)
  static async saveVideoToPermanentLocation(tempUri: string): Promise<string> {
    if (Platform.OS === 'web') {
      // On web, this shouldn't be called anymore - use saveWebVideoBlob instead
      console.warn('⚠️ saveVideoToPermanentLocation called on web - use saveWebVideoBlob instead');
      return tempUri;
    }

    try {
      const fileName = `feeb_${Date.now()}.mp4`;
      const permanentUri = `${FileSystem.documentDirectory}feebs/${fileName}`;
      
      // Create feebs directory if it doesn't exist
      const feebsDir = `${FileSystem.documentDirectory}feebs/`;
      const dirInfo = await FileSystem.getInfoAsync(feebsDir);
      if (!dirInfo.exists) {
        await FileSystem.makeDirectoryAsync(feebsDir, { intermediates: true });
      }

      // Copy the temporary file to permanent location
      await FileSystem.copyAsync({
        from: tempUri,
        to: permanentUri,
      });

      console.log('📁 Video saved to permanent location:', permanentUri);
      return permanentUri;
    } catch (error) {
      console.error('Error saving video permanently:', error);
      throw error;
    }
  }

  // Create a new feeb record
  static createFeeb(videoUri: string, originalVideoUri: string): Feeb {
    return {
      id: `feeb_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      uri: videoUri,
      originalVideoUri,
      createdAt: new Date().toISOString(),
      isWebBlob: Platform.OS === 'web',
    };
  }

  // Delete a feeb (platform-specific cleanup)
  static async deleteFeeb(feebId: string): Promise<void> {
    try {
      const feebs = await this.getAllFeebs();
      const feebToDelete = feebs.find(feeb => feeb.id === feebId);
      
      if (feebToDelete) {
        // Clean up the video file/data
        if (Platform.OS === 'web') {
          // Remove from AsyncStorage if it's a web video ID
          if (feebToDelete.isWebBlob && !feebToDelete.uri.startsWith('data:') && !feebToDelete.uri.startsWith('blob:')) {
            const storageKey = WEB_VIDEO_STORAGE_KEY + feebToDelete.uri;
            
            // Check if it's chunked and clean up all chunks
            const chunkCountStr = await AsyncStorage.getItem(`${storageKey}_chunks`);
            if (chunkCountStr) {
              const chunkCount = parseInt(chunkCountStr, 10);
              console.log(`🗑️ Cleaning up ${chunkCount} chunks for video:`, feebToDelete.uri);
              
              // Remove chunk count
              await AsyncStorage.removeItem(`${storageKey}_chunks`);
              
              // Remove all chunks
              for (let i = 0; i < chunkCount; i++) {
                await AsyncStorage.removeItem(`${storageKey}_chunk_${i}`);
              }
            } else {
              // Remove single data URL
              await AsyncStorage.removeItem(storageKey);
            }
            
            console.log('🗑️ Web: Deleted video data for ID:', feebToDelete.uri);
          }
          // If it was an old blob URL, just log (already invalid anyway)
          if (feebToDelete.uri.startsWith('blob:')) {
            console.log('🗑️ Web: Old blob URL will be garbage collected');
          }
        } else {
          // Delete the actual file on mobile
          await FileSystem.deleteAsync(feebToDelete.uri, { idempotent: true });
          console.log('🗑️ Mobile: Deleted video file');
        }
      }

      // Remove from feebs list
      const updatedFeebs = feebs.filter(feeb => feeb.id !== feebId);
      await AsyncStorage.setItem(FEEBS_STORAGE_KEY, JSON.stringify(updatedFeebs));
      
    } catch (error) {
      console.error('Error deleting feeb:', error);
      throw error;
    }
  }

  // Helper: Check if a URI is a web video ID
  static isWebVideoId(uri: string): boolean {
    return Platform.OS === 'web' && !uri.startsWith('data:') && !uri.startsWith('blob:') && !uri.startsWith('http');
  }

  // Helper: Get display URI for a feeb (handles web video IDs)
  static async getFeebDisplayUri(feeb: Feeb): Promise<string> {
    if (Platform.OS === 'web' && feeb.isWebBlob) {
      // If it's an old blob URL, it's no longer valid
      if (feeb.uri.startsWith('blob:')) {
        console.log('⚠️ Old blob URL detected, cannot retrieve data:', feeb.uri);
        return ''; // Return empty string to trigger error state
      }
      
      // If it's already a data URL, return as-is
      if (feeb.uri.startsWith('data:')) {
        console.log('✅ Data URL found, returning directly');
        return feeb.uri;
      }
      
      // If it's a web video ID, retrieve the data URL
      if (this.isWebVideoId(feeb.uri)) {
        console.log('🔍 Retrieving data URL for video ID:', feeb.uri);
        const dataUrl = await this.getWebVideoDataUrl(feeb.uri);
        if (dataUrl) {
          console.log('✅ Data URL retrieved successfully');
          return dataUrl;
        } else {
          console.log('❌ Failed to retrieve data URL for video ID:', feeb.uri);
          return ''; // Return empty string to trigger error state
        }
      }
    }
    
    // For mobile or direct URIs, return as-is
    return feeb.uri;
  }

  // Utility: Clear all invalid web videos (for debugging/cleanup)
  static async clearInvalidWebVideos(): Promise<number> {
    if (Platform.OS !== 'web') {
      return 0;
    }

    try {
      const feebs = await AsyncStorage.getItem(FEEBS_STORAGE_KEY);
      const feebList: Feeb[] = feebs ? JSON.parse(feebs) : [];
      
      let deletedCount = 0;
      const validFeebs = [];
      
      for (const feeb of feebList) {
        if (feeb.isWebBlob && feeb.uri.startsWith('blob:')) {
          console.log('🧹 Removing invalid blob URL feeb:', feeb.id);
          deletedCount++;
        } else {
          validFeebs.push(feeb);
        }
      }
      
      if (deletedCount > 0) {
        await AsyncStorage.setItem(FEEBS_STORAGE_KEY, JSON.stringify(validFeebs));
        console.log(`🧹 Cleared ${deletedCount} invalid web videos`);
      }
      
      return deletedCount;
    } catch (error) {
      console.error('Error clearing invalid web videos:', error);
      return 0;
    }
  }
}

// File: src/navigation/RootNavigator.tsx
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { Ionicons } from '@expo/vector-icons';

import FeedsScreen from '../screens/FeedsScreen';
import ContentsScreen from '../screens/ContentsScreen';
import ChatsScreen from '../screens/ChatsScreen';
import ProfileScreen from '../screens/ProfileScreen';
import CreateFeebScreen from '../screens/CreateFeebScreen';
import UploadContentScreen from '../screens/UploadContentScreen';
import RecordReactionScreen from '../screens/RecordReactionScreen';

const Tab = createBottomTabNavigator();
const Stack = createNativeStackNavigator();

// Create a placeholder component instead of inline function
function UploadPlaceholder() {
  return null;
}

function MainTabs({ navigation }: any) {
  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        tabBarIcon: ({ color, size }) => {
          let iconName: any;
          if (route.name === 'Feebs') iconName = 'shield';
          else if (route.name === 'Contents') iconName = 'film';
          else if (route.name === 'Chats') iconName = 'chatbubble';
          else if (route.name === 'Profile') iconName = 'person';
          else if (route.name === 'Upload') iconName = 'add-circle';
          return <Ionicons name={iconName} size={size} color={color} />;
        },
        tabBarActiveTintColor: '#00CFFF',
        tabBarInactiveTintColor: 'gray',
        headerShown: false,
      })}
    >
      <Tab.Screen name="Feebs" component={FeedsScreen} />
      <Tab.Screen name="Contents" component={ContentsScreen} />
      <Tab.Screen
        name="Upload"
        component={UploadPlaceholder}
        options={{
          tabBarIcon: ({ size }) => (
            <Ionicons
              name="add-circle"
              size={size + 8}
              color="#00CFFF"
              style={{ marginTop: -10 }}
            />
          ),
        }}
        listeners={({ navigation }) => ({
          tabPress: (e) => {
            e.preventDefault();
            navigation.navigate('UploadContent');
          },
        })}
      />
      <Tab.Screen name="Chats" component={ChatsScreen} />
      <Tab.Screen name="Profile" component={ProfileScreen} />
    </Tab.Navigator>
  );
}

export default function RootNavigator() {
  return (
    <NavigationContainer>
      <Stack.Navigator>
        <Stack.Screen name="MainTabs" component={MainTabs} options={{ headerShown: false }} />
        <Stack.Screen name="CreateFeeb" component={CreateFeebScreen} options={{ presentation: 'modal', title: 'Record Reaction' }} />
        <Stack.Screen name="UploadContent" component={UploadContentScreen} options={{ title: 'Upload Video' }} />
        <Stack.Screen name="RecordReaction" component={RecordReactionScreen} options={{ title: 'React to Video' }} />
      </Stack.Navigator>
    </NavigationContainer>
  );
}

// File: modules/expo-headphone-detection/src/index.ts
export interface HeadphoneInfo {
  isConnected: boolean;
  deviceType: 'wired' | 'bluetooth' | 'none';
  deviceName: string;
}

export interface HeadphoneListener {
  remove(): void;
}

// Create a functional headphone detection manager
const createHeadphoneDetectionManager = () => {
  let listeners: ((info: HeadphoneInfo) => void)[] = [];
  
  const getCurrentStatus = async (): Promise<HeadphoneInfo> => {
    // Web implementation for now
    if (typeof window !== 'undefined' && navigator.mediaDevices) {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const audioOutputs = devices.filter(d => d.kind === 'audiooutput');
        
        const headphoneKeywords = ['headphone', 'bluetooth', 'airpods', 'beats', 'wireless'];
        
        const connectedDevice = audioOutputs.find(device => {
          const label = device.label.toLowerCase();
          return headphoneKeywords.some(keyword => label.includes(keyword)) ||
                 (device.deviceId !== 'default' && device.deviceId !== 'communications' && label);
        });
        
        const hasHeadphones = !!connectedDevice;
        
        const deviceType = connectedDevice?.label.toLowerCase().includes('bluetooth') || 
                          connectedDevice?.label.toLowerCase().includes('wireless') || 
                          connectedDevice?.label.toLowerCase().includes('airpods') ? 'bluetooth' : 
                          hasHeadphones ? 'wired' : 'none';
        
        return {
          isConnected: hasHeadphones,
          deviceType: deviceType as 'wired' | 'bluetooth' | 'none',
          deviceName: connectedDevice?.label || ''
        };
      } catch (error) {
        console.log('Headphone detection error:', error);
      }
    }
    
    return {
      isConnected: false,
      deviceType: 'none',
      deviceName: ''
    };
  };

  const addListener = (eventName: string, listener: (info: HeadphoneInfo) => void): HeadphoneListener => {
    listeners.push(listener);
    return {
      remove: () => {
        const index = listeners.indexOf(listener);
        if (index > -1) {
          listeners.splice(index, 1);
        }
      }
    };
  };

  const removeAllListeners = (): void => {
    listeners = [];
  };

  const handleDeviceChange = async () => {
    const status = await getCurrentStatus();
    listeners.forEach(listener => listener(status));
  };

  const startListening = (): void => {
    if (typeof window !== 'undefined' && navigator.mediaDevices) {
      navigator.mediaDevices.addEventListener('devicechange', handleDeviceChange);
    }
  };

  const stopListening = (): void => {
    if (typeof window !== 'undefined' && navigator.mediaDevices) {
      navigator.mediaDevices.removeEventListener('devicechange', handleDeviceChange);
    }
  };

  return {
    getCurrentStatus,
    addListener,
    removeAllListeners,
    startListening,
    stopListening
  };
};

// Export the singleton instance
export default createHeadphoneDetectionManager();

// File: modules/expo-headphone-detection/src/ExpoHeadphoneDetectionModule.web.ts
// 3. Fixed modules/expo-headphone-detection/src/ExpoHeadphoneDetectionModule.web.ts
import { EventEmitter } from 'expo-modules-core';

interface HeadphoneInfo {
  isConnected: boolean;
  deviceType: 'wired' | 'bluetooth' | 'none';
  deviceName: string;
}

class ExpoHeadphoneDetectionModuleWeb extends EventEmitter {
  private deviceChangeHandler: (() => Promise<void>) | null = null;

  async getCurrentStatus(): Promise<HeadphoneInfo> {
    try {
      if (!navigator.mediaDevices?.enumerateDevices) {
        return { isConnected: false, deviceType: 'none', deviceName: '' };
      }

      const devices = await navigator.mediaDevices.enumerateDevices();
      const audioOutputs = devices.filter(device => device.kind === 'audiooutput');
      
      console.log('🔊 Available audio devices:', audioOutputs);

      // Common headphone brands and keywords  
      const headphoneKeywords = [
        'headphone', 'headset', 'bluetooth', 'wireless',
        'airpods', 'beats', 'sony', 'bose', 'sennheiser',
        'audio-technica', 'skull', 'jbl', 'plantronics'
      ];

      let connectedDevice = null;
      let deviceType: 'wired' | 'bluetooth' | 'none' = 'none';

      for (const device of audioOutputs) {
        const label = device.label.toLowerCase();
        
        // Check for headphone keywords
        const hasKeyword = headphoneKeywords.some(keyword => 
          label.includes(keyword)
        );
        
        // Check if it's not the default speaker
        const isNotDefault = device.deviceId !== 'default' && 
                           device.deviceId !== 'communications' &&
                           label && label !== '';
        
        if (hasKeyword || isNotDefault) {
          connectedDevice = device;
          
          // Determine device type
          if (label.includes('bluetooth') || label.includes('wireless') || 
              label.includes('airpods') || label.includes('beats')) {
            deviceType = 'bluetooth';
          } else {
            deviceType = 'wired';
          }
          break;
        }
      }

      const result: HeadphoneInfo = {
        isConnected: !!connectedDevice,
        deviceType: deviceType,
        deviceName: connectedDevice?.label || ''
      };

      console.log('🎧 Headphone detection result:', result);
      return result;
    } catch (error) {
      console.error('❌ Web headphone detection error:', error);
      return { isConnected: false, deviceType: 'none', deviceName: '' };
    }
  }

  startListening(): void {
    if (navigator.mediaDevices?.addEventListener && !this.deviceChangeHandler) {
      this.deviceChangeHandler = async () => {
        const status = await this.getCurrentStatus();
        this.emit('headphoneStatusChanged', status);
      };
      navigator.mediaDevices.addEventListener('devicechange', this.deviceChangeHandler);
    }
  }

  stopListening(): void {
    if (navigator.mediaDevices?.removeEventListener && this.deviceChangeHandler) {
      navigator.mediaDevices.removeEventListener('devicechange', this.deviceChangeHandler);
      this.deviceChangeHandler = null;
    }
  }
}

export default new ExpoHeadphoneDetectionModuleWeb();


// File: modules/expo-headphone-detection/src/ExpoHeadphoneDetectionModule.ts
// 2. Fixed modules/expo-headphone-detection/src/ExpoHeadphoneDetectionModule.ts
import { NativeModulesProxy } from 'expo-modules-core';

// Define the native module interface
interface ExpoHeadphoneDetectionModuleType {
  getCurrentStatus(): Promise<{
    isConnected: boolean;
    deviceType: 'wired' | 'bluetooth' | 'none';
    deviceName: string;
  }>;
  
  startListening?(): void;
  stopListening?(): void;
}

// Import the actual native module or use web fallback
const ExpoHeadphoneDetectionModule: ExpoHeadphoneDetectionModuleType = 
  NativeModulesProxy.ExpoHeadphoneDetection ?? require('./ExpoHeadphoneDetectionModule.web').default;

export default ExpoHeadphoneDetectionModule;

// File: modules/expo-headphone-detection/package.json
{
  "name": "expo-headphone-detection",
  "version": "1.0.0",
  "description": "Production-grade headphone detection for Expo",
  "main": "src/index.ts",
  "types": "src/index.ts",
  "scripts": {
    "build": "expo-module build",
    "clean": "expo-module clean"
  },
  "keywords": ["expo", "headphones", "audio", "detection"],
  "peerDependencies": {
    "expo": "*",
    "expo-modules-core": "*"
  },
  "devDependencies": {
    "expo-modules-core": "*"
  }
}

// File: modules/expo-headphone-detection/expo-module.config.json
{
  "platforms": ["ios", "android", "web"],
  "ios": {
    "modules": ["ExpoHeadphoneDetectionModule"]
  },
  "android": {
    "modules": ["expo.modules.headphonedetection.ExpoHeadphoneDetectionModule"]
  }
}

// File: index.ts
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);


// File: tsconfig.json
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true,
    // turn off checking of default lib files (speeds up builds & avoids weird missing-lib errors)
    "skipLibCheck": true,
    // explicitly list the runtime libs you need (no more “node 2”!)
    "lib": ["ESNext", "DOM", "DOM.Iterable"],
    // pick only the @types packages you actually use
    "types": ["react", "react-native"],
    // where to look for those @types
    "typeRoots": ["./node_modules/@types"]
  },
  // don't accidentally include things under node_modules
  "exclude": ["node_modules"]
}


// File: package.json
{
  "name": "feeb",
  "license": "0BSD",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "expo start --clear",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "tunnel": "expo start --web --tunnel",
    "dev": "npx expo start --dev-client",
    "build": "eas build --profile development --platform android"
  },
  "dependencies": {
    "@expo/config-plugins": "^10.0.3",
    "@expo/metro-runtime": "~5.0.4",
    "@react-native-async-storage/async-storage": "^2.1.0",
    "@react-navigation/bottom-tabs": "^7.4.1",
    "@react-navigation/native": "^7.1.14",
    "@react-navigation/native-stack": "^7.3.20",
    "expo": "~53.0.12",
    "expo-av": "~15.1.6",
    "expo-camera": "~16.1.9",
    "expo-dev-client": "~5.2.2",
    "expo-file-system": "~18.1.0",
    "expo-headphone-detection": "file:modules/expo-headphone-detection",
    "expo-status-bar": "~2.2.3",
    "expo-video": "~2.1.1",
    "prettier": "^3.6.0",
    "react": "19.0.0",
    "react-dom": "19.0.0",
    "react-native": "0.79.4",
    "react-native-audio-recorder-player": "^3.6.14",
    "react-native-permissions": "^5.4.1",
    "react-native-safe-area-context": "^5.5.0",
    "react-native-screens": "^4.11.1",
    "react-native-web": "^0.20.0"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/react": "~19.0.10",
    "@types/react-native": "^0.72.8",
    "typescript": "~5.8.3"
  },
  "private": true
}


// File: eas.json
{
  "cli": {
    "version": ">= 5.2.0"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal",
      "ios": {
        "resourceClass": "m-medium"
      },
      "android": {
        "buildType": "apk",
        "gradleCommand": ":app:assembleDebug"
      }
    },
    "preview": {
      "ios": {
        "simulator": true,
        "resourceClass": "m-medium"
      },
      "android": {
        "buildType": "apk"
      }
    },
    "production": {
      "ios": {
        "resourceClass": "m-medium"
      },
      "android": {
        "buildType": "aab"
      }
    }
  },
  "submit": {
    "production": {
      "ios": {
        "appleId": "ignaciosenese@gmail.com",
        "ascAppId": "your-app-store-connect-app-id",
        "appleTeamId": "your-apple-team-id"
      },
      "android": {
        "serviceAccountKeyPath": "./android-service-account.json",
        "track": "internal"
      }
    }
  }
}


// File: types.d.ts
declare global {
  interface HTMLVideoElement {
    audioTracks?: AudioTrackList;
  }
}

export {};

// File: app.json
{
  "expo": {
    "name": "feeb",
    "slug": "feeb",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "newArchEnabled": true,
    "splash": {
      "image": "./assets/splash-icon.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.yourcompany.feeb"
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      },
      "edgeToEdgeEnabled": true,
      "permissions": [
        "CAMERA",
        "RECORD_AUDIO",
        "WRITE_EXTERNAL_STORAGE",
        "MODIFY_AUDIO_SETTINGS",
        "BLUETOOTH",
        "BLUETOOTH_ADMIN",
        "android.permission.CAMERA",
        "android.permission.RECORD_AUDIO",
        "android.permission.MODIFY_AUDIO_SETTINGS"
      ],
      "package": "com.yourcompany.feeb"
    },
    "web": {
      "favicon": "./assets/favicon.png"
    },
    "plugins": [
      "expo-dev-client",
      [
        "expo-camera",
        {
          "cameraPermission": "Allow Feeb to access your camera to record reactions."
        }
      ],
      [
        "expo-av",
        {
          "microphonePermission": "Allow Feeb to access your microphone to record audio."
        }
      ]
    ],
    "extra": {
      "eas": {
        "projectId": "56d9b1ec-e143-4ab2-a906-9e424f45e203"
      }
    }
  }
}


// File: App.tsx
// App.tsx
import RootNavigator from './src/navigation/RootNavigator';

export default function App() {
  return <RootNavigator />;
}


// File: cspell.json
{
  "words": [
    "feeb",
    "Feeb",
    "Feebs",
    "chunker",
    "chatbubble",
    "videocam",
    "timeslice",
    "Horan",
    "Timecodes"
  ]
}

// File: navigation/RootNavigator.tsx
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { Ionicons } from '@expo/vector-icons';
import FeedsScreen from '../src/screens/FeedsScreen';
import ChatsScreen from '../src/screens/ChatsScreen';
import ContentsScreen from '../src/screens/ContentsScreen';
import CreateFeebScreen from '../src/screens/CreateFeebScreen';
import ProfileScreen from '../src/screens/ProfileScreen';
import RecordReactionScreen from '../src/screens/RecordReactionScreen';
import UploadContentScreen from '../src/screens/UploadContentScreen';



const Tab = createBottomTabNavigator();
const Stack = createNativeStackNavigator();

// Create a placeholder component instead of inline function
function UploadPlaceholder() {
  return null;
}

function MainTabs({ navigation }: any) {
  return (
    <Tab.Navigator
      screenOptions={({ route }) => ({
        tabBarIcon: ({ color, size }) => {
          let iconName: any;
          if (route.name === 'Feebs') iconName = 'shield';
          else if (route.name === 'Contents') iconName = 'film';
          else if (route.name === 'Chats') iconName = 'chatbubble';
          else if (route.name === 'Profile') iconName = 'person';
          else if (route.name === 'Upload') iconName = 'add-circle';
          return <Ionicons name={iconName} size={size} color={color} />;
        },
        tabBarActiveTintColor: '#00CFFF',
        tabBarInactiveTintColor: 'gray',
        headerShown: false,
      })}
    >
      <Tab.Screen name="Feebs" component={FeedsScreen} />
      <Tab.Screen name="Contents" component={ContentsScreen} />
      <Tab.Screen
        name="Upload"
        component={UploadPlaceholder}
        options={{
          tabBarIcon: ({ size }) => (
            <Ionicons
              name="add-circle"
              size={size + 8}
              color="#00CFFF"
              style={{ marginTop: -10 }}
            />
          ),
        }}
        listeners={({ navigation }) => ({
          tabPress: (e) => {
            e.preventDefault();
            navigation.navigate('UploadContent');
          },
        })}
      />
      <Tab.Screen name="Chats" component={ChatsScreen} />
      <Tab.Screen name="Profile" component={ProfileScreen} />
    </Tab.Navigator>
  );
}

export default function RootNavigator() {
  return (
    <NavigationContainer>
      <Stack.Navigator>
        <Stack.Screen name="MainTabs" component={MainTabs} options={{ headerShown: false }} />
        <Stack.Screen name="CreateFeeb" component={CreateFeebScreen} options={{ presentation: 'modal', title: 'Record Reaction' }} />
        <Stack.Screen name="UploadContent" component={UploadContentScreen} options={{ title: 'Upload Video' }} />
        <Stack.Screen name="RecordReaction" component={RecordReactionScreen} options={{ title: 'React to Video' }} />
      </Stack.Navigator>
    </NavigationContainer>
  );
}

// File: .expo/prebuild/cached-packages.json
{
  "dependencies": "8361b1cd1ead6d1cf8c06b6b6132d856cd84abe8",
  "devDependencies": "eeb9fe3375e80699b8c6c8fc042f7bf27b14c6ec"
}


// File: .expo/devices.json
{
  "devices": [
    {
      "installationId": "d993cdee-790a-41b0-b2c2-f9c85c156817",
      "lastUsed": 1751357381069
    }
  ]
}


// File: .expo/README.md
> Why do I have a folder named ".expo" in my project?
The ".expo" folder is created when an Expo project is started using "expo start" command.
> What do the files contain?
- "devices.json": contains information about devices that have recently opened this project. This is used to populate the "Development sessions" list in your development builds.
- "settings.json": contains the server configuration that is used to serve the application manifest.
> Should I commit the ".expo" folder?
No, you should not share the ".expo" folder. It does not contain any information that is relevant for other developers working on the project, it is specific to your machine.
Upon project creation, the ".expo" folder is already added to your ".gitignore" file.


// File: .expo/packager-info.json
{
  "expoServerPort": 19000,
  "packagerPort": 19000
}


// File: .expo/settings.json
{
  "hostType": "lan",
  "lanType": "ip",
  "dev": true,
  "minify": false,
  "urlRandomness": "KByB508",
  "https": false,
  "scheme": null
}
