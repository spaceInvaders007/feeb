

// File: index.ts
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);


// File: tsconfig.json
{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true
  }
}


// File: package.json
{
  "name": "feeb",
  "license": "0BSD",
  "version": "1.0.0",
  "main": "index.ts",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@expo/metro-runtime": "~5.0.4",
    "@react-native-async-storage/async-storage": "^2.1.0",
    "@react-navigation/bottom-tabs": "^7.4.1",
    "@react-navigation/native": "^7.1.14",
    "@react-navigation/native-stack": "^7.3.20",
    "expo": "~53.0.12",
    "expo-camera": "~16.1.8",
    "expo-file-system": "~18.1.0",
    "expo-status-bar": "~2.2.3",
    "expo-video": "~2.1.1",
    "prettier": "^3.6.0",
    "react": "19.0.0",
    "react-dom": "19.0.0",
    "react-native": "0.79.4",
    "react-native-safe-area-context": "^5.5.0",
    "react-native-screens": "^4.11.1",
    "react-native-web": "^0.20.0"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/react": "~19.0.10",
    "@types/react-native": "^0.72.8",
    "typescript": "~5.8.3"
  },
  "private": true
}


// File: components/SideBySidePlayer.tsx
import React, { useState, useEffect } from 'react';
import {
  View,
  StyleSheet,
  TouchableOpacity,
  Text,
  Dimensions,
  Modal,
  Platform,
} from 'react-native';
import { VideoView, useVideoPlayer } from 'expo-video';
import { Ionicons } from '@expo/vector-icons';

const { width: screenWidth, height: screenHeight } = Dimensions.get('window');

interface SideBySidePlayerProps {
  visible: boolean;
  originalVideoUri: string;
  reactionVideoUri: string;
  onClose: () => void;
  feebId: string;
  createdAt: string;
  isWebBlob?: boolean;
}

export default function SideBySidePlayer({
  visible,
  originalVideoUri,
  reactionVideoUri,
  onClose,
  feebId,
  createdAt,
  isWebBlob
}: SideBySidePlayerProps) {
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [layout, setLayout] = useState<'side-by-side' | 'top-bottom'>('top-bottom');

  // DEBUG LOGGING - Log all props when component mounts
  useEffect(() => {
    if (visible) {
      console.log('🎬 SideBySidePlayer - Props received:', {
        visible,
        originalVideoUri,
        reactionVideoUri,
        feebId,
        createdAt,
        isWebBlob,
        platform: Platform.OS
      });
      
      console.log('🎬 SideBySidePlayer - URI Analysis:', {
        originalVideoUriLength: originalVideoUri?.length || 0,
        reactionVideoUriLength: reactionVideoUri?.length || 0,
        reactionVideoUriType: reactionVideoUri?.startsWith('data:') ? 'DATA_URL' : 
                               reactionVideoUri?.startsWith('file:') ? 'FILE_URL' : 
                               reactionVideoUri?.startsWith('http') ? 'HTTP_URL' : 'UNKNOWN',
        originalVideoUriType: originalVideoUri?.startsWith('http') ? 'HTTP_URL' : 'OTHER'
      });
    }
  }, [visible, originalVideoUri, reactionVideoUri, feebId, isWebBlob]);

  // Create video players
  const originalPlayer = useVideoPlayer(originalVideoUri, (player) => {
    player.loop = false;
    player.muted = false;
  });

  const reactionPlayer = useVideoPlayer(reactionVideoUri, (player) => {
    player.loop = false;
    player.muted = true; // Reaction is muted to avoid audio conflict
  });

  // DEBUG: Log player creation
  useEffect(() => {
    if (visible) {
      console.log('🎬 SideBySidePlayer - Players created:', {
        originalPlayerCreated: !!originalPlayer,
        reactionPlayerCreated: !!reactionPlayer
      });
    }
  }, [visible, originalPlayer, reactionPlayer]);

  // Sync players
  useEffect(() => {
    if (!visible) return;

    const syncVideos = () => {
      if (isPlaying) {
        console.log('🎬 SideBySidePlayer - Starting playback');
        originalPlayer.play();
        reactionPlayer.play();
        
        // Also control HTML video element if it exists
        if (isWebBlob && reactionVideoUri.startsWith('data:')) {
          const videoElements = document.querySelectorAll('video[src^="data:video"]');
          videoElements.forEach((video: any) => {
            if (video.src === reactionVideoUri) {
              console.log('🎬 SideBySidePlayer - Starting HTML video playback');
              video.currentTime = originalPlayer.currentTime;
              video.play().catch(console.error);
            }
          });
        }
      } else {
        console.log('🎬 SideBySidePlayer - Pausing playback');
        originalPlayer.pause();
        reactionPlayer.pause();
        
        // Also control HTML video element if it exists
        if (isWebBlob && reactionVideoUri.startsWith('data:')) {
          const videoElements = document.querySelectorAll('video[src^="data:video"]');
          videoElements.forEach((video: any) => {
            if (video.src === reactionVideoUri) {
              console.log('🎬 SideBySidePlayer - Pausing HTML video playback');
              video.pause();
            }
          });
        }
      }
    };

    syncVideos();
  }, [isPlaying, visible, originalPlayer, reactionPlayer, isWebBlob, reactionVideoUri]);

  // Reset when modal opens
  useEffect(() => {
    if (visible) {
      console.log('🎬 SideBySidePlayer - Resetting players');
      originalPlayer.currentTime = 0;
      reactionPlayer.currentTime = 0;
      setCurrentTime(0);
      setIsPlaying(false);
    }
  }, [visible, originalPlayer, reactionPlayer]);

  // Track playback progress
  useEffect(() => {
    if (!visible) return;

    const interval = setInterval(() => {
      if (originalPlayer && originalPlayer.playing) {
        setCurrentTime(originalPlayer.currentTime);
        
        // Keep videos in sync
        const timeDiff = Math.abs(originalPlayer.currentTime - reactionPlayer.currentTime);
        if (timeDiff > 0.2) { // 200ms tolerance
          reactionPlayer.currentTime = originalPlayer.currentTime;
        }
      }
    }, 100);

    return () => clearInterval(interval);
  }, [visible, originalPlayer, reactionPlayer]);

  // Get duration
  useEffect(() => {
    const subscription = originalPlayer.addListener('statusChange', (status) => {
      console.log('🎬 SideBySidePlayer - Original player status:', status);
      if (status.status === 'readyToPlay' && originalPlayer.duration > 0) {
        setDuration(originalPlayer.duration);
        console.log('🎬 SideBySidePlayer - Duration set:', originalPlayer.duration);
      }
    });

    return () => subscription?.remove();
  }, [originalPlayer]);

  // DEBUG: Log reaction player status
  useEffect(() => {
    const subscription = reactionPlayer.addListener('statusChange', (status) => {
      console.log('🎬 SideBySidePlayer - Reaction player status:', status);
    });

    return () => subscription?.remove();
  }, [reactionPlayer]);

  const handlePlayPause = () => {
    console.log('🎬 SideBySidePlayer - Play/Pause clicked, current state:', isPlaying);
    setIsPlaying(!isPlaying);
  };

  const handleSeek = (position: number) => {
    const newTime = (position / 100) * duration;
    console.log('🎬 SideBySidePlayer - Seeking to:', newTime);
    originalPlayer.currentTime = newTime;
    reactionPlayer.currentTime = newTime;
    setCurrentTime(newTime);
  };

  const toggleLayout = () => {
    const newLayout = layout === 'side-by-side' ? 'top-bottom' : 'side-by-side';
    console.log('🎬 SideBySidePlayer - Layout changed to:', newLayout);
    setLayout(newLayout);
  };

  const formatTime = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const progress = duration > 0 ? (currentTime / duration) * 100 : 0;

  if (!visible) return null;

  return (
    <Modal
      visible={visible}
      animationType="slide"
      onRequestClose={onClose}
      statusBarTranslucent
    >
      <View style={styles.container}>
        {/* Header */}
        <View style={styles.header}>
          <TouchableOpacity onPress={onClose} style={styles.closeButton}>
            <Ionicons name="arrow-back" size={24} color="white" />
          </TouchableOpacity>
          
          <View style={styles.headerInfo}>
            <Text style={styles.headerTitle}>Feeb Playback</Text>
            <Text style={styles.headerSubtitle}>{new Date(createdAt).toLocaleDateString()}</Text>
          </View>

          <TouchableOpacity onPress={toggleLayout} style={styles.layoutButton}>
            <Ionicons 
              name={layout === 'side-by-side' ? 'phone-portrait' : 'phone-landscape'} 
              size={24} 
              color="white" 
            />
          </TouchableOpacity>
        </View>

        {/* Video Container */}
        <View style={[
          styles.videoContainer,
          layout === 'side-by-side' ? styles.sideBySideLayout : styles.topBottom
        ]}>
          {/* Original Video */}
          <View style={[
            styles.videoWrapper,
            layout === 'side-by-side' ? styles.halfWidth : styles.halfHeight
          ]}>
            <Text style={styles.videoLabel}>Original Video</Text>
            <VideoView
              style={styles.video}
              player={originalPlayer}
              allowsFullscreen={false}
              allowsPictureInPicture={false}
              showsTimecodes={false}
            />
          </View>

          {/* Reaction Video */}
          <View style={[
            styles.videoWrapper,
            layout === 'side-by-side' ? styles.halfWidth : styles.halfHeight
          ]}>
            <Text style={styles.videoLabel}>Your Reaction</Text>
            {isWebBlob && reactionVideoUri.startsWith('data:') ? (
              <video
                src={reactionVideoUri}
                style={styles.video as any}
                muted={false} // Enable audio for debugging
                controls // Show controls for debugging
                autoPlay={isPlaying}
                loop={false}
                onTimeUpdate={(e) => {
                  // Sync with original if needed
                  const video = e.target as HTMLVideoElement;
                  const timeDiff = Math.abs(originalPlayer.currentTime - video.currentTime);
                  if (timeDiff > 0.2 && originalPlayer.playing) {
                    video.currentTime = originalPlayer.currentTime;
                  }
                }}
                onError={(e) => {
                  console.error('🎬 SideBySidePlayer - Reaction video error:', e);
                }}
                onLoadedData={() => {
                  console.log('🎬 SideBySidePlayer - Reaction video loaded successfully');
                }}
                onCanPlay={() => {
                  console.log('🎬 SideBySidePlayer - Reaction video can play');
                }}
                onLoadStart={() => {
                  console.log('🎬 SideBySidePlayer - Reaction video load started');
                }}
              />
            ) : (
              <VideoView
                style={styles.video}
                player={reactionPlayer}
                allowsFullscreen={false}
                allowsPictureInPicture={false}
                showsTimecodes={false}
              />
            )}
          </View>
        </View>

        {/* Controls */}
        <View style={styles.controls}>
          {/* Progress Bar */}
          <View style={styles.progressContainer}>
            <Text style={styles.timeText}>{formatTime(currentTime)}</Text>
            <TouchableOpacity 
              style={styles.progressBarContainer}
              onPress={(event) => {
                const { locationX } = event.nativeEvent;
                const containerWidth = screenWidth - 120; // Account for time labels
                const position = Math.max(0, Math.min(100, (locationX / containerWidth) * 100));
                handleSeek(position);
              }}
              activeOpacity={1}
            >
              <View style={styles.progressBar}>
                <View style={[styles.progressFill, { width: `${progress}%` }]} />
                <View style={[styles.progressThumb, { left: `${progress}%` }]} />
              </View>
            </TouchableOpacity>
            <Text style={styles.timeText}>{formatTime(duration)}</Text>
          </View>

          {/* Play Controls */}
          <View style={styles.playControls}>
            <TouchableOpacity
              style={styles.controlButton}
              onPress={() => handleSeek(0)}
            >
              <Ionicons name="play-back" size={24} color="white" />
            </TouchableOpacity>

            <TouchableOpacity
              style={styles.playButton}
              onPress={handlePlayPause}
            >
              <Ionicons 
                name={isPlaying ? "pause" : "play"} 
                size={32} 
                color="white" 
              />
            </TouchableOpacity>

            <TouchableOpacity
              style={styles.controlButton}
              onPress={() => handleSeek(100)}
            >
              <Ionicons name="play-forward" size={24} color="white" />
            </TouchableOpacity>
          </View>

          {/* Info */}
          <View style={styles.infoContainer}>
            <Text style={styles.infoText}>
              Layout: {layout === 'side-by-side' ? 'Side by Side' : 'Top & Bottom'}
            </Text>
            {isWebBlob && (
              <Text style={styles.infoText}>Platform: Web</Text>
            )}
          </View>
        </View>
      </View>
    </Modal>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#000',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingTop: 50,
    paddingHorizontal: 20,
    paddingBottom: 10,
    backgroundColor: 'rgba(0, 0, 0, 0.8)',
  },
  closeButton: {
    padding: 8,
  },
  headerInfo: {
    flex: 1,
    alignItems: 'center',
  },
  headerTitle: {
    color: 'white',
    fontSize: 18,
    fontWeight: 'bold',
  },
  headerSubtitle: {
    color: '#ccc',
    fontSize: 14,
  },
  layoutButton: {
    padding: 8,
  },
  videoContainer: {
    flex: 1,
    padding: 10,
  },
  sideBySideLayout: {
    flexDirection: 'row',
  },
  topBottom: {
    flexDirection: 'column',
  },
  videoWrapper: {
    position: 'relative',
    backgroundColor: '#111',
    borderRadius: 8,
    overflow: 'hidden',
    margin: 5,
  },
  halfWidth: {
    flex: 1,
  },
  halfHeight: {
    flex: 1,
  },
  videoLabel: {
    position: 'absolute',
    top: 10,
    left: 10,
    color: 'white',
    fontSize: 12,
    fontWeight: 'bold',
    backgroundColor: 'rgba(0, 0, 0, 0.7)',
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 4,
    zIndex: 1,
  },
  video: {
    width: '100%',
    height: '100%',
  },
  controls: {
    backgroundColor: 'rgba(0, 0, 0, 0.9)',
    paddingHorizontal: 20,
    paddingVertical: 15,
  },
  progressContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 15,
  },
  timeText: {
    color: 'white',
    fontSize: 12,
    minWidth: 40,
    textAlign: 'center',
  },
  progressBarContainer: {
    flex: 1,
    marginHorizontal: 10,
  },
  progressBar: {
    height: 4,
    backgroundColor: 'rgba(255, 255, 255, 0.3)',
    borderRadius: 2,
    position: 'relative',
  },
  progressFill: {
    height: '100%',
    backgroundColor: '#00CFFF',
    borderRadius: 2,
  },
  progressThumb: {
    position: 'absolute',
    top: -6,
    width: 16,
    height: 16,
    backgroundColor: '#00CFFF',
    borderRadius: 8,
    marginLeft: -8,
  },
  playControls: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 10,
  },
  controlButton: {
    padding: 15,
    marginHorizontal: 20,
  },
  playButton: {
    backgroundColor: '#00CFFF',
    borderRadius: 30,
    padding: 15,
    marginHorizontal: 20,
  },
  infoContainer: {
    alignItems: 'center',
  },
  infoText: {
    color: '#ccc',
    fontSize: 12,
    textAlign: 'center',
  },
});

// File: components/ProfileTabs.tsx
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';
import React, { useState } from 'react';

export default function ProfileTabs() {
  const [active, setActive] = useState<'feebs' | 'contents'>('feebs');

  return (
    <View style={styles.wrapper}>
      <TouchableOpacity
        style={[styles.tab, active === 'feebs' && styles.active]}
        onPress={() => setActive('feebs')}
      >
        <Text style={styles.label}>Feebs</Text>
      </TouchableOpacity>
      <TouchableOpacity
        style={[styles.tab, active === 'contents' && styles.active]}
        onPress={() => setActive('contents')}
      >
        <Text style={styles.label}>Contents</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  wrapper: {
    flexDirection: 'row',
    marginVertical: 16,
  },
  tab: {
    flex: 1,
    alignItems: 'center',
    padding: 12,
    borderBottomWidth: 2,
    borderBottomColor: 'transparent',
  },
  active: {
    borderBottomColor: '#00CFFF',
  },
  label: {
    fontSize: 16,
    fontWeight: '600',
  },
});


// File: components/WebCamera.tsx
import React, { useRef, useEffect, useState, useCallback } from 'react';
import { View, StyleSheet, Platform, Text } from 'react-native';

interface WebCameraProps {
  isRecording: boolean;
  onCameraReady: () => void;
  onRecordingComplete: (videoBlob: Blob) => void;
}

export default function WebCamera({ isRecording, onCameraReady, onRecordingComplete }: WebCameraProps) {
  const videoRef = useRef<HTMLVideoElement>(null);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const streamRef = useRef<MediaStream | null>(null);
  const recordingStateRef = useRef<'idle' | 'starting' | 'recording' | 'stopping'>('idle');
  
  const [hasPermission, setHasPermission] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isInitializing, setIsInitializing] = useState(false);
  const [debugInfo, setDebugInfo] = useState<string>('');

  // Enhanced logging
  const logState = useCallback((action: string, extra?: any) => {
    console.log(`📷 [WebCamera-${action}]`, {
      isRecording,
      recordingState: recordingStateRef.current,
      hasMediaRecorder: !!mediaRecorderRef.current,
      mediaRecorderState: mediaRecorderRef.current?.state || 'none',
      hasStream: !!streamRef.current,
      ...extra
    });
  }, [isRecording]);

  useEffect(() => {
    if (Platform.OS === 'web') {
      const timer = setTimeout(() => {
        initializeCamera();
      }, 100);
      return () => clearTimeout(timer);
    }
    return () => {
      cleanup();
    };
  }, []);

  useEffect(() => {
    if (Platform.OS === 'web' && hasPermission && streamRef.current && videoRef.current) {
      console.log('🔗 Setting up video element with existing stream...');
      videoRef.current.srcObject = streamRef.current;
      videoRef.current.play().catch(console.log);
    }
  }, [hasPermission]);

  // Enhanced recording state management
  useEffect(() => {
    if (Platform.OS === 'web' && hasPermission) {
      logState('RECORDING_PROP_CHANGED');
      
      if (isRecording && recordingStateRef.current === 'idle') {
        startRecording();
      } else if (!isRecording && recordingStateRef.current === 'recording') {
        stopRecording();
      }
    }
  }, [isRecording, hasPermission, logState]);

  const checkCameraAvailability = async () => {
    try {
      console.log('🔍 Checking camera availability...');
      
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        throw new Error('Media devices API not supported in this browser');
      }

      const devices = await navigator.mediaDevices.enumerateDevices();
      const videoDevices = devices.filter(device => device.kind === 'videoinput');
      
      console.log('📱 Available video devices:', videoDevices.length);
      setDebugInfo(`Found ${videoDevices.length} camera(s)`);

      if (videoDevices.length === 0) {
        throw new Error('No camera devices found on this device');
      }

      return videoDevices;
    } catch (error) {
      console.error('❌ Camera availability check failed:', error);
      throw error;
    }
  };

  const initializeCamera = async () => {
    if (isInitializing) {
      console.log('⏳ Camera initialization already in progress...');
      return;
    }

    try {
      setIsInitializing(true);
      setError(null);
      console.log('🌐 Initializing web camera...');
      
      await checkCameraAvailability();

      const constraintOptions = [
        {
          video: { 
            facingMode: 'user',
            width: { ideal: 1280 },
            height: { ideal: 720 }
          }, 
          audio: true 
        },
        {
          video: { 
            facingMode: 'user',
            width: { ideal: 640 },
            height: { ideal: 480 }
          }, 
          audio: true 
        },
        {
          video: true, 
          audio: true 
        },
        {
          video: true, 
          audio: false 
        }
      ];

      let stream: MediaStream | null = null;
      let lastError: Error | null = null;

      for (let i = 0; i < constraintOptions.length; i++) {
        try {
          console.log(`🎥 Attempting camera access with configuration ${i + 1}...`);
          setDebugInfo(`Trying camera config ${i + 1}/${constraintOptions.length}`);
          stream = await navigator.mediaDevices.getUserMedia(constraintOptions[i]);
          console.log(`✅ Camera access successful with configuration ${i + 1}`);
          setDebugInfo(`Camera access successful!`);
          break;
        } catch (err) {
          lastError = err as Error;
          console.log(`❌ Configuration ${i + 1} failed:`, err);
          setDebugInfo(`Config ${i + 1} failed: ${lastError.message}`);
          continue;
        }
      }

      if (!stream) {
        throw lastError || new Error('Failed to access camera with all configurations');
      }

      streamRef.current = stream;

      if (videoRef.current) {
        console.log('📺 Setting up video element...');
        videoRef.current.srcObject = stream;
        videoRef.current.play().catch(console.log);
      }

      console.log('🚀 Stream ready, triggering callback');
      setHasPermission(true);
      setDebugInfo('Camera ready!');
      onCameraReady();
    } catch (error) {
      console.error('❌ Failed to initialize camera:', error);
      setHasPermission(false);
      
      let errorMessage = 'Failed to access camera';
      if (error instanceof Error) {
        if (error.name === 'NotFoundError') {
          errorMessage = 'No camera found. Please connect a camera and try again.';
        } else if (error.name === 'NotAllowedError') {
          errorMessage = 'Camera permission denied. Please allow camera access and refresh the page.';
        } else if (error.name === 'NotReadableError') {
          errorMessage = 'Camera is busy or unavailable. Please close other applications using the camera.';
        } else if (error.message.includes('Media devices API not supported')) {
          errorMessage = 'Camera not supported in this browser. Please use Chrome, Firefox, or Safari.';
        } else if (error.message.includes('No camera devices found')) {
          errorMessage = 'No camera detected. Please connect a camera or check your device settings.';
        }
      }
      
      setError(errorMessage);
    } finally {
      setIsInitializing(false);
    }
  };

  const startRecording = useCallback(() => {
    if (!streamRef.current) {
      console.error('❌ No stream available for recording');
      return;
    }

    if (recordingStateRef.current !== 'idle') {
      console.log('⚠️ Recording not in idle state, current:', recordingStateRef.current);
      return;
    }

    try {
      recordingStateRef.current = 'starting';
      console.log('🎥 Starting web recording...');
      logState('START_RECORDING');
      
      const mimeTypes = [
        'video/webm;codecs=vp9,opus',
        'video/webm;codecs=vp8,opus', 
        'video/webm;codecs=h264,opus',
        'video/webm',
        'video/mp4'
      ];

      let mediaRecorder: MediaRecorder | null = null;
      for (const mimeType of mimeTypes) {
        if (MediaRecorder.isTypeSupported(mimeType)) {
          console.log(`📼 Using MIME type: ${mimeType}`);
          mediaRecorder = new MediaRecorder(streamRef.current, { mimeType });
          break;
        }
      }

      if (!mediaRecorder) {
        mediaRecorder = new MediaRecorder(streamRef.current);
        console.log('📼 Using default MediaRecorder settings');
      }

      const chunks: BlobPart[] = [];

      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          chunks.push(event.data);
          console.log(`📊 Recording chunk: ${event.data.size} bytes (State: ${recordingStateRef.current})`);
        }
      };

      mediaRecorder.onstop = () => {
        console.log('🛑 Web recording stopped');
        logState('RECORDING_STOPPED', { chunksCount: chunks.length });
        
        const videoBlob = new Blob(chunks, { type: mediaRecorder?.mimeType || 'video/webm' });
        console.log(`📁 Created video blob: ${videoBlob.size} bytes`);
        
        recordingStateRef.current = 'idle';
        onRecordingComplete(videoBlob);
      };

      mediaRecorder.onerror = (event) => {
        console.error('❌ MediaRecorder error:', event);
        recordingStateRef.current = 'idle';
        logState('RECORDING_ERROR', { error: event });
      };

      mediaRecorder.onstart = () => {
        console.log('✅ MediaRecorder started');
        recordingStateRef.current = 'recording';
        logState('RECORDING_STARTED');
      };

      mediaRecorder.start(1000); // Collect data every second
      mediaRecorderRef.current = mediaRecorder;
      console.log('🎬 MediaRecorder.start() called');

    } catch (error) {
      console.error('❌ Failed to start recording:', error);
      recordingStateRef.current = 'idle';
      logState('START_RECORDING_ERROR', { error });
      setError('Failed to start recording. Please try again.');
    }
  }, [logState, onRecordingComplete]);

  const stopRecording = useCallback(() => {
    logState('STOP_RECORDING_CALLED');
    
    if (recordingStateRef.current !== 'recording') {
      console.log('⚠️ Not in recording state, current:', recordingStateRef.current);
      return;
    }

    if (!mediaRecorderRef.current) {
      console.log('⚠️ No MediaRecorder available');
      recordingStateRef.current = 'idle';
      return;
    }

    if (mediaRecorderRef.current.state !== 'recording') {
      console.log('⚠️ MediaRecorder not in recording state:', mediaRecorderRef.current.state);
      recordingStateRef.current = 'idle';
      return;
    }

    try {
      recordingStateRef.current = 'stopping';
      console.log('🛑 Stopping web recording...');
      logState('STOPPING_RECORDING');
      
      mediaRecorderRef.current.stop();
      mediaRecorderRef.current = null;
    } catch (error) {
      console.error('❌ Error stopping recording:', error);
      recordingStateRef.current = 'idle';
      logState('STOP_RECORDING_ERROR', { error });
    }
  }, [logState]);

  const cleanup = () => {
    console.log('🧹 Cleaning up camera resources...');
    
    // Stop recording if active
    if (recordingStateRef.current === 'recording' && mediaRecorderRef.current) {
      try {
        mediaRecorderRef.current.stop();
      } catch (e) {
        console.log('Error stopping recorder during cleanup:', e);
      }
    }
    
    // Clean up stream
    if (streamRef.current) {
      streamRef.current.getTracks().forEach(track => {
        track.stop();
        console.log(`🛑 Stopped track: ${track.kind}`);
      });
      streamRef.current = null;
    }
    
    // Reset refs
    mediaRecorderRef.current = null;
    recordingStateRef.current = 'idle';
  };

  if (Platform.OS !== 'web') {
    return null;
  }

  if (error) {
    return (
      <View style={styles.errorContainer}>
        <Text style={styles.errorTitle}>Camera Error</Text>
        <Text style={styles.errorMessage}>{error}</Text>
        <Text style={styles.errorHint}>
          Troubleshooting tips:{'\n'}
          • Check camera permissions in browser settings{'\n'}
          • Ensure no other apps are using the camera{'\n'}
          • Try refreshing the page{'\n'}
          • Use Chrome, Firefox, or Safari for best results
        </Text>
      </View>
    );
  }

  if (isInitializing || !hasPermission) {
    return (
      <View style={styles.loadingContainer}>
        <Text style={styles.loadingText}>
          {isInitializing ? 'Initializing camera...' : 'Waiting for camera...'}
        </Text>
        {debugInfo ? (
          <Text style={styles.debugText}>{debugInfo}</Text>
        ) : null}
        {isInitializing ? (
          <Text 
            style={styles.retryButton}
            onPress={() => {
              console.log('🔄 Manual retry triggered');
              setIsInitializing(false);
              setTimeout(() => initializeCamera(), 100);
            }}
          >
            Tap to retry
          </Text>
        ) : null}
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <video
        ref={videoRef}
        style={styles.video}
        autoPlay
        muted
        playsInline
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    position: 'relative',
  },
  video: {
    width: '100%',
    height: '100%',
    objectFit: 'cover',
  } as any,

  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
    backgroundColor: '#f8f8f8',
  },
  errorTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    color: '#d32f2f',
    marginBottom: 10,
    textAlign: 'center',
  },
  errorMessage: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
    marginBottom: 15,
  },
  errorHint: {
    fontSize: 14,
    color: '#888',
    textAlign: 'left',
    lineHeight: 20,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f0f0f0',
  },
  loadingText: {
    fontSize: 16,
    color: '#666',
    textAlign: 'center',
  },
  debugText: {
    fontSize: 14,
    color: '#888',
    textAlign: 'center',
    marginTop: 10,
    fontStyle: 'italic',
  },
  retryButton: {
    fontSize: 16,
    color: '#00CFFF',
    textAlign: 'center',
    marginTop: 20,
    textDecorationLine: 'underline',
    cursor: 'pointer',
  } as any,
});

// File: components/FeebCamera.tsx
import React, { useEffect, useRef, useState } from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';
import { CameraView, CameraType, useCameraPermissions } from 'expo-camera';
import type { CameraRecordingOptions } from 'expo-camera';
import { Ionicons } from '@expo/vector-icons';

export default function FeebCamera() {
  const [permission, requestPermission] = useCameraPermissions();
  const [isRecording, setIsRecording] = useState(false);
  const cameraRef = useRef<CameraView | null>(null);

  const handleRecord = async () => {
    if (!cameraRef.current) return;

    if (isRecording) {
      cameraRef.current.stopRecording();
      setIsRecording(false);
    } else {
      setIsRecording(true);
      try {
        const recordingOptions: CameraRecordingOptions = {
          // You can add options here if needed
        };
        const video = await cameraRef.current.recordAsync(recordingOptions);
      } catch (error) {
        console.error('Recording failed:', error);
      } finally {
        setIsRecording(false);
      }
    }
  };

  if (!permission) {
    // Camera permissions are still loading
    return <Text>Loading...</Text>;
  }

  if (!permission.granted) {
    // Camera permissions are not granted yet
    return (
      <View style={styles.container}>
        <Text style={styles.message}>We need your permission to show the camera</Text>
        <TouchableOpacity onPress={requestPermission} style={styles.permissionButton}>
          <Text style={styles.permissionButtonText}>Grant Permission</Text>
        </TouchableOpacity>
      </View>
    );
  }

  return (
    <View style={{ flex: 1 }}>
      <CameraView
        ref={cameraRef}
        style={{ flex: 1 }}
        facing="front"
        mode="video"
      >
        <TouchableOpacity style={styles.button} onPress={handleRecord}>
          <Ionicons
            name={isRecording ? 'square' : 'videocam'}
            size={32}
            color="white"
          />
        </TouchableOpacity>
      </CameraView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  message: {
    textAlign: 'center',
    marginBottom: 20,
    fontSize: 16,
  },
  permissionButton: {
    backgroundColor: '#00CFFF',
    padding: 12,
    borderRadius: 8,
  },
  permissionButtonText: {
    color: 'white',
    fontSize: 16,
    fontWeight: 'bold',
  },
  button: {
    position: 'absolute',
    bottom: 40,
    alignSelf: 'center',
    backgroundColor: '#00CFFF',
    padding: 14,
    borderRadius: 40,
  },
});

// File: screens/ContentsScreen.tsx
import React, { useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Image,
  Dimensions,
} from "react-native";
import { useNavigation } from "@react-navigation/native";
import { Ionicons } from "@expo/vector-icons";
import { VideoView, useVideoPlayer } from 'expo-video';

const screenWidth = Dimensions.get("window").width;

export default function ContentsScreen() {
  const navigation = useNavigation<any>();

  const [videoStarted, setVideoStarted] = useState(false);
  const [thumbnailError, setThumbnailError] = useState(false);

  const videoUri = "https://samplelib.com/lib/preview/mp4/sample-5s.mp4";

  // Better thumbnail URLs that are more reliable
  const thumbnailUri = thumbnailError 
    ? 'https://picsum.photos/640/360' // Fallback to Lorem Picsum
    : 'https://images.unsplash.com/photo-1611162617474-5b21e879e113?w=640&h=360&fit=crop'; // Unsplash video thumbnail

  // Setup video player
  const player = useVideoPlayer(videoUri, (player) => {
    player.loop = false;
    player.muted = false;
  });

  return (
    <View style={styles.container}>
      <Text style={styles.header}>Contents</Text>
      <View style={styles.card}>
        <View style={styles.userRow}>
          <Image
            source={{ uri: "https://picsum.photos/100/100?random=1" }}
            style={styles.avatar}
          />
          <View>
            <Text style={styles.username}>
              Lilian Espech • <Text style={styles.follow}>Following</Text>
            </Text>
            <Text style={styles.location}>Los Angeles, USA</Text>
          </View>
          <Text style={styles.time}>1 min ago</Text>
        </View>

        {/* Thumbnail or video */}
        <TouchableOpacity
          activeOpacity={0.9}
          onPress={() => navigation.navigate("RecordReaction", { videoUri })}
          style={styles.videoWrapper}
        >
          {videoStarted ? (
            <VideoView
              style={styles.video}
              player={player}
              allowsFullscreen={true}
              allowsPictureInPicture={false}
              showsTimecodes={true}
            />
          ) : (
            <View style={styles.thumbnailContainer}>
              {/* Thumbnail image */}
              <Image 
                source={{ uri: thumbnailUri }} 
                style={styles.thumbnail}
                resizeMode="cover"
                onError={() => {
                  console.log('Thumbnail failed to load, trying fallback');
                  setThumbnailError(true);
                }}
                onLoad={() => {
                  console.log('Thumbnail loaded successfully');
                }}
              />
              
              {/* Overlay with play button */}
              <View style={styles.feebOverlay}>
                <View style={styles.playButton}>
                  <Ionicons name="videocam" size={36} color="white" />
                </View>
                <Text style={styles.feebText}>Tap to Feeb it</Text>
              </View>
            </View>
          )}
        </TouchableOpacity>

        <Text style={styles.caption}>231 ❤️ · 76 🔁 · +41 reactions</Text>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, padding: 16, backgroundColor: "#fff" },
  header: { fontSize: 22, fontWeight: "700", marginBottom: 16 },
  card: { marginBottom: 24 },
  userRow: {
    flexDirection: "row",
    alignItems: "center",
    gap: 12,
    marginBottom: 8,
  },
  avatar: { width: 40, height: 40, borderRadius: 20 },
  username: { fontWeight: "bold" },
  follow: { color: "#00CFFF" },
  location: { fontSize: 12, color: "#666" },
  time: { marginLeft: "auto", fontSize: 12, color: "#aaa" },
  videoWrapper: {
    width: "100%",
    aspectRatio: 16 / 9,
    borderRadius: 12,
    overflow: "hidden",
    backgroundColor: "#f0f0f0", // Light gray background as fallback
    position: "relative",
  },
  video: {
    width: "100%",
    height: "100%",
  },
  thumbnailContainer: {
    width: "100%",
    height: "100%",
    position: "relative",
  },
  thumbnail: {
    width: "100%",
    height: "100%",
  },
  feebOverlay: {
    position: "absolute",
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: "rgba(0, 0, 0, 0.3)", // Semi-transparent overlay
  },
  playButton: {
    width: 80,
    height: 80,
    borderRadius: 40,
    backgroundColor: "rgba(0, 207, 255, 0.9)",
    alignItems: "center",
    justifyContent: "center",
    marginBottom: 12,
  },
  feebText: {
    fontSize: 16,
    fontWeight: "600",
    color: "white",
    textShadowColor: "rgba(0, 0, 0, 0.7)",
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 3,
  },
  caption: { marginTop: 8, fontSize: 14, color: "#444" },
});

// File: screens/FeedsScreen.tsx
import React from 'react';
import { View, Text, StyleSheet, Image, TouchableOpacity } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

export default function FeedsScreen() {
  return (
    <View style={styles.container}>
      {/* Top camera feed */}
      <View style={styles.cameraPreview}>
        <Image
          source={{ uri: 'https://placekitten.com/400/300' }}
          style={styles.cameraImage}
          resizeMode="cover"
        />
        <TouchableOpacity style={styles.muteBtn}>
          <Ionicons name="volume-mute" size={20} color="#fff" />
        </TouchableOpacity>
      </View>

      {/* Bottom video feed */}
      <View style={styles.videoSection}>
        <Image
          source={{
            uri: 'https://images.unsplash.com/photo-1535713875002-d1d0cf377fde',
          }}
          style={styles.videoImage}
          resizeMode="cover"
        />
        <TouchableOpacity style={[styles.muteBtn, { top: 10 }]}>
          <Ionicons name="volume-mute" size={20} color="#fff" />
        </TouchableOpacity>

        <View style={styles.sideActions}>
          <TouchableOpacity style={styles.iconWrap}>
            <Ionicons name="share-social" size={28} color="#333" />
            <Text style={styles.iconLabel}>824</Text>
          </TouchableOpacity>
          <TouchableOpacity style={styles.iconWrap}>
            <Ionicons name="chatbubble-ellipses" size={28} color="#333" />
            <Text style={styles.iconLabel}>200</Text>
          </TouchableOpacity>
          <TouchableOpacity style={styles.iconWrap}>
            <Ionicons name="heart" size={28} color="#E91E63" />
            <Text style={styles.iconLabel}>1.2k</Text>
          </TouchableOpacity>
        </View>

        <View style={styles.userInfo}>
          <Text style={styles.userText}>
            <Text style={{ fontWeight: 'bold' }}>Lilian Espech</Text> •{' '}
            <Text style={{ color: '#00CFFF' }}>Follow</Text>
          </Text>
          <Text style={styles.location}>Los Angeles, USA</Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#fff',
  },
  cameraPreview: {
    height: 160,
    margin: 16,
    borderRadius: 16,
    overflow: 'hidden',
    position: 'relative',
  },
  cameraImage: {
    width: '100%',
    height: '100%',
  },
  muteBtn: {
    position: 'absolute',
    top: 10,
    right: 10,
    backgroundColor: '#0008',
    padding: 6,
    borderRadius: 20,
  },
  videoSection: {
    flex: 1,
    position: 'relative',
  },
  videoImage: {
    width: '100%',
    height: '100%',
  },
  sideActions: {
    position: 'absolute',
    right: 10,
    bottom: 80,
    alignItems: 'center',
  },
  iconWrap: {
    marginBottom: 20,
    alignItems: 'center',
  },
  iconLabel: {
    fontSize: 12,
    color: '#333',
    marginTop: 2,
  },
  userInfo: {
    position: 'absolute',
    bottom: 20,
    left: 16,
  },
  userText: {
    color: '#000',
    fontSize: 16,
    marginBottom: 2,
  },
  location: {
    fontSize: 12,
    color: '#666',
  },
});

// File: screens/RecordReactionScreen.tsx
import React, { useEffect, useRef, useState, useCallback } from "react";
import {
  View,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
  Text,
  Dimensions,
  Platform,
  Alert,
} from "react-native";
import { VideoView, useVideoPlayer } from 'expo-video';
import { CameraView, useCameraPermissions } from "expo-camera";
import type { CameraRecordingOptions } from "expo-camera";
import { Ionicons } from "@expo/vector-icons";
import { useNavigation, useRoute } from "@react-navigation/native";
import { FeebStorage } from "../utils/FeebStorage";
import WebCamera from "../components/WebCamera";
import * as FileSystem from 'expo-file-system';

const { width: screenWidth } = Dimensions.get("screen");

// Debug logger utility
class DebugLogger {
  static log(category: string, message: string, data?: any) {
    const timestamp = new Date().toISOString().substr(11, 12);
    console.log(`[${timestamp}] 🔍 [${category}] ${message}`, data ? JSON.stringify(data, null, 2) : '');
  }

  static error(category: string, message: string, error?: any) {
    const timestamp = new Date().toISOString().substr(11, 12);
    console.error(`[${timestamp}] ❌ [${category}] ${message}`, error);
  }
}

export default function RecordReactionScreen() {
  const navigation = useNavigation<any>();
  const route = useRoute<any>();
  const cameraRef = useRef<CameraView>(null);

  // States
  const [permission, requestPermission] = useCameraPermissions();
  const [videoReady, setVideoReady] = useState(false);
  const [cameraReady, setCameraReady] = useState(false);
  const [countdown, setCountdown] = useState<number | null>(null);
  const [isRecording, setIsRecording] = useState(false);
  const [hasStartedFlow, setHasStartedFlow] = useState(false);
  const [isSaving, setIsSaving] = useState(false);

  // Recording refs
  const isActivelyRecordingRef = useRef(false);
  const stopTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const webRecordingBlobRef = useRef<Blob | null>(null);
  const recordingRef = useRef<Promise<any> | null>(null);
  const recordingStartTimeRef = useRef<number | null>(null);

  const videoUri = route.params?.videoUri ?? "https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4";

  const player = useVideoPlayer(videoUri, (player) => {
    player.loop = false;
    player.muted = false;
  });

  // Enhanced debug logging
  useEffect(() => {
    DebugLogger.log('COMPONENT', 'Render state', {
      videoReady,
      cameraReady,
      isRecording,
      hasStartedFlow,
      isSaving,
      platform: Platform.OS
    });
  });

  // Hide header and setup permissions
  useEffect(() => {
    navigation.setOptions({ headerShown: false });
    
    if (Platform.OS !== 'web') {
      if (!permission) {
        DebugLogger.log('PERMISSIONS', 'Permission object is null');
      } else if (!permission.granted) {
        DebugLogger.log('PERMISSIONS', 'Camera permission not granted, requesting...');
        requestPermission();
      } else {
        DebugLogger.log('PERMISSIONS', 'Camera permission granted');
        setCameraReady(true);
      }
    } else {
      DebugLogger.log('PERMISSIONS', 'Web platform, skipping camera permissions');
    }
  }, [permission, navigation]);

  // Video ready listener
  useEffect(() => {
    const subscription = player.addListener('statusChange', (status) => {
      DebugLogger.log('VIDEO', 'Status change', status);
      
      if (status.status === 'readyToPlay' && !videoReady) {
        DebugLogger.log('VIDEO', 'Video ready', {
          duration: player.duration,
          currentTime: player.currentTime
        });
        setVideoReady(true);
      }
    });

    return () => subscription?.remove();
  }, [player, videoReady]);

  // Start countdown when both are ready
  useEffect(() => {
    const isReady = videoReady && cameraReady;
    const shouldStart = isReady && !hasStartedFlow && !isRecording && !isSaving;

    DebugLogger.log('FLOW', 'Flow check', {
      isReady,
      shouldStart,
      videoReady,
      cameraReady,
      hasStartedFlow,
      isRecording,
      isSaving
    });

    if (shouldStart) {
      DebugLogger.log('FLOW', 'Starting countdown');
      setHasStartedFlow(true);
      setCountdown(3); // Longer countdown for debugging
    }
  }, [videoReady, cameraReady, hasStartedFlow, isRecording, isSaving]);

  // Countdown timer
  useEffect(() => {
    if (countdown !== null && countdown > 0) {
      DebugLogger.log('COUNTDOWN', `Countdown: ${countdown}`);
      const timer = setTimeout(() => setCountdown(countdown - 1), 1000);
      return () => clearTimeout(timer);
    } else if (countdown === 0) {
      DebugLogger.log('COUNTDOWN', 'Countdown finished, starting recording');
      setCountdown(null);
      startRecording();
    }
  }, [countdown]);

  // Validate recording file
  const validateRecordingFile = async (uri: string): Promise<boolean> => {
    try {
      DebugLogger.log('VALIDATION', 'Validating recording file', { uri });
      
      const fileInfo = await FileSystem.getInfoAsync(uri);
      DebugLogger.log('VALIDATION', 'File info', fileInfo);
      
      if (!fileInfo.exists) {
        DebugLogger.error('VALIDATION', 'File does not exist');
        return false;
      }

      if (fileInfo.size === 0) {
        DebugLogger.error('VALIDATION', 'File is empty');
        return false;
      }

      // Check file extension
      const extension = uri.split('.').pop()?.toLowerCase() || '';
      const isVideo = ['mp4', 'mov', 'm4v', 'avi'].includes(extension);
      const isPhoto = ['jpg', 'jpeg', 'png', 'gif'].includes(extension);

      DebugLogger.log('VALIDATION', 'File type analysis', {
        extension,
        isVideo,
        isPhoto,
        size: fileInfo.size
      });

      if (isPhoto) {
        DebugLogger.error('VALIDATION', '🚨 CRITICAL: Camera recorded a PHOTO instead of VIDEO!');
        Alert.alert('❌ Recording Issue', 'Camera captured a photo instead of video!');
        return false;
      }

      if (!isVideo) {
        DebugLogger.error('VALIDATION', 'Unknown file type');
        return false;
      }

      DebugLogger.log('VALIDATION', '✅ Video file validation passed');
      return true;

    } catch (error) {
      DebugLogger.error('VALIDATION', 'File validation error', error);
      return false;
    }
  };

  // Start recording - ENHANCED DEBUG VERSION
  const startRecording = useCallback(async () => {
    DebugLogger.log('RECORDING', 'START RECORDING CALLED');

    if (isActivelyRecordingRef.current) {
      DebugLogger.log('RECORDING', 'Already recording, aborting');
      return;
    }

    try {
      isActivelyRecordingRef.current = true;
      setIsRecording(true);
      recordingStartTimeRef.current = Date.now();
      
      DebugLogger.log('RECORDING', 'Recording state set, starting video playback');
      
      // Start video playback
      player.currentTime = 0;
      player.play();
      
      DebugLogger.log('RECORDING', 'Video playback started');

      // Start camera recording based on platform
      if (Platform.OS === 'web') {
        DebugLogger.log('RECORDING', 'Web platform - WebCamera should handle recording');
      } else {
        DebugLogger.log('RECORDING', 'Mobile platform - starting camera recording');
        
        if (!cameraRef.current) {
          throw new Error('Camera ref is null');
        }

        // Enhanced recording options
        const recordingOptions: CameraRecordingOptions = {
          maxDuration: 60, // Longer duration for testing
        };

        DebugLogger.log('RECORDING', 'Calling recordAsync with options', recordingOptions);
        
        // Start recording
        const recordingPromise = cameraRef.current.recordAsync(recordingOptions);
        recordingRef.current = recordingPromise;
        
        DebugLogger.log('RECORDING', 'recordAsync called, promise created');
        
        // Set up promise handlers for debugging
        recordingPromise
          .then((result) => {
            DebugLogger.log('RECORDING', 'Recording promise resolved', result);
          })
          .catch((error) => {
            DebugLogger.error('RECORDING', 'Recording promise rejected', error);
          });
      }

      // Set stop timeout
      const duration = player.duration;
      const timeoutMs = duration > 0 ? Math.ceil(duration * 1000) + 2000 : 15000; // Extra time for debugging
      
      DebugLogger.log('RECORDING', 'Setting stop timeout', {
        videoDuration: duration,
        timeoutMs
      });
      
      stopTimeoutRef.current = setTimeout(() => {
        DebugLogger.log('RECORDING', 'Timeout fired - calling stopRecording');
        stopRecording();
      }, timeoutMs);

    } catch (error: any) {
      DebugLogger.error('RECORDING', 'Failed to start recording', error);
      isActivelyRecordingRef.current = false;
      setIsRecording(false);
      Alert.alert('Recording Error', `Failed to start recording: ${error?.message || 'Unknown error'}`);
    }
  }, [player]);

  // Stop recording - ENHANCED DEBUG VERSION
  const stopRecording = useCallback(async () => {
    DebugLogger.log('RECORDING', 'STOP RECORDING CALLED');

    if (!isActivelyRecordingRef.current) {
      DebugLogger.log('RECORDING', 'Not actively recording, aborting stop');
      return;
    }

    const recordingDuration = recordingStartTimeRef.current ? 
      Date.now() - recordingStartTimeRef.current : 0;

    DebugLogger.log('RECORDING', 'Stopping recording', {
      recordingDuration: `${recordingDuration}ms`
    });

    try {
      isActivelyRecordingRef.current = false;
      setIsRecording(false);
      setIsSaving(true);

      // Clear timeout
      if (stopTimeoutRef.current) {
        clearTimeout(stopTimeoutRef.current);
        stopTimeoutRef.current = null;
      }

      // Stop and save recording based on platform
      if (Platform.OS === 'web') {
        DebugLogger.log('RECORDING', 'Web platform - handling web recording');
        
        let attempts = 0;
        const maxAttempts = 50;
        
        while (!webRecordingBlobRef.current && attempts < maxAttempts) {
          DebugLogger.log('RECORDING', `Waiting for web blob, attempt ${attempts + 1}/${maxAttempts}`);
          await new Promise(resolve => setTimeout(resolve, 100));
          attempts++;
        }
        
        if (webRecordingBlobRef.current) {
          DebugLogger.log('RECORDING', 'Web blob available', {
            size: webRecordingBlobRef.current.size,
            type: webRecordingBlobRef.current.type
          });
          await saveWebRecording(webRecordingBlobRef.current);
        } else {
          DebugLogger.error('RECORDING', 'No web blob available after waiting');
          Alert.alert("Error", "No recording available");
        }
      } else {
        DebugLogger.log('RECORDING', 'Mobile platform - stopping camera recording');
        
        // Stop the camera recording
        if (cameraRef.current) {
          DebugLogger.log('RECORDING', 'Calling stopRecording on camera');
          cameraRef.current.stopRecording();
        }
        
        // Wait for recording to complete
        if (recordingRef.current) {
          DebugLogger.log('RECORDING', 'Waiting for recording promise to resolve');
          
          try {
            const recording = await recordingRef.current;
            DebugLogger.log('RECORDING', 'Recording promise resolved', {
              recording,
              uri: recording?.uri,
              type: typeof recording
            });
            
            if (recording && recording.uri) {
              // Validate the recording file
              const isValid = await validateRecordingFile(recording.uri);
              
              if (isValid) {
                await saveMobileRecording(recording);
              } else {
                Alert.alert("Recording Issue", "The recorded file appears to be invalid or is a photo instead of video.");
              }
            } else {
              DebugLogger.error('RECORDING', 'Invalid recording result');
              Alert.alert("Error", "Recording failed - no video file created");
            }
          } catch (recordingError: any) {
            DebugLogger.error('RECORDING', 'Error waiting for recording', recordingError);
            Alert.alert("Error", `Recording failed: ${recordingError?.message || 'Unknown error'}`);
          }
        } else {
          DebugLogger.error('RECORDING', 'No recording promise available');
          Alert.alert("Error", "No recording was started");
        }
      }

    } catch (error: any) {
      DebugLogger.error('RECORDING', 'Error stopping recording', error);
      Alert.alert('Error', `Failed to save recording: ${error?.message || 'Unknown error'}`);
    } finally {
      setIsSaving(false);
      webRecordingBlobRef.current = null;
      recordingRef.current = null;
      recordingStartTimeRef.current = null;
      
      setTimeout(() => {
        navigation.goBack();
      }, 2000); // Longer delay for debugging
    }
  }, [navigation]);

  // Manual stop for testing
  const manualStop = useCallback(() => {
    DebugLogger.log('RECORDING', 'Manual stop pressed');
    stopRecording();
  }, [stopRecording]);

  // Camera ready handler
  const handleCameraReady = useCallback(() => {
    DebugLogger.log('CAMERA', 'Camera ready callback fired');
    setCameraReady(true);
  }, []);

  // Web recording complete handler
  const handleWebRecordingComplete = useCallback((videoBlob: Blob) => {
    DebugLogger.log('WEB_RECORDING', 'Web recording completed', {
      size: videoBlob.size,
      type: videoBlob.type
    });
    webRecordingBlobRef.current = videoBlob;
  }, []);

  // Save web recording
  const saveWebRecording = useCallback(async (blob: Blob) => {
    try {
      DebugLogger.log('SAVE', 'Saving web recording', {
        size: blob.size,
        type: blob.type
      });
      
      const permanentUri = await FeebStorage.saveWebVideoBlob(blob);
      const newFeeb = FeebStorage.createFeeb(permanentUri, videoUri);
      await FeebStorage.saveFeeb(newFeeb);
      
      DebugLogger.log('SAVE', 'Web recording saved successfully', { permanentUri });
      Alert.alert("Success!", "Your reaction has been saved!");
      
    } catch (error: any) {
      DebugLogger.error('SAVE', 'Error saving web recording', error);
      throw error;
    }
  }, [videoUri]);

  // Save mobile recording
  const saveMobileRecording = useCallback(async (recording: any) => {
    try {
      DebugLogger.log('SAVE', 'Saving mobile recording', {
        uri: recording.uri,
        recording
      });
      
      const permanentUri = await FeebStorage.saveVideoToPermanentLocation(recording.uri);
      const newFeeb = FeebStorage.createFeeb(permanentUri, videoUri);
      await FeebStorage.saveFeeb(newFeeb);
      
      DebugLogger.log('SAVE', 'Mobile recording saved successfully', { permanentUri });
      Alert.alert("Success!", "Your reaction has been saved!");
      
    } catch (error: any) {
      DebugLogger.error('SAVE', 'Error saving mobile recording', error);
      throw error;
    }
  }, [videoUri]);

  // Permission check
  if (Platform.OS !== 'web' && !permission?.granted) {
    return (
      <View style={styles.permissionContainer}>
        <Ionicons name="camera" size={48} color="#666" />
        <Text style={styles.permissionText}>Camera permission required</Text>
        <TouchableOpacity onPress={requestPermission} style={styles.permissionButton}>
          <Text style={styles.permissionButtonText}>Grant Permission</Text>
        </TouchableOpacity>
      </View>
    );
  }

  const isAllReady = videoReady && cameraReady;

  return (
    <View style={styles.container}>
      {/* Debug Info Overlay */}
      <View style={styles.debugInfo}>
        <Text style={styles.debugText}>
          Platform: {Platform.OS} | Video: {videoReady ? '✅' : '❌'} | Camera: {cameraReady ? '✅' : '❌'}
        </Text>
        <Text style={styles.debugText}>
          Recording: {isRecording ? '🔴' : '⚫'} | Saving: {isSaving ? '💾' : '⚫'}
        </Text>
      </View>

      {/* Back button */}
      <TouchableOpacity
        style={styles.backButton}
        onPress={() => navigation.goBack()}
        disabled={isRecording || isSaving}
      >
        <View style={[styles.backButtonCircle, (isRecording || isSaving) && styles.disabledButton]}>
          <Ionicons name="arrow-back" size={24} color="#fff" />
        </View>
      </TouchableOpacity>

      {/* Recording indicator */}
      {isRecording && (
        <View style={styles.recordingIndicator}>
          <View style={styles.redDot} />
          <Text style={styles.recordingText}>REC</Text>
          <TouchableOpacity style={styles.manualStopButton} onPress={manualStop}>
            <Ionicons name="stop" size={20} color="#fff" />
          </TouchableOpacity>
        </View>
      )}

      {/* Video */}
      <View style={styles.half}>
        <VideoView
          style={styles.video}
          player={player}
          allowsFullscreen={false}
          allowsPictureInPicture={false}
          showsTimecodes={false}
        />
      </View>

      {/* Camera */}
      <View style={styles.half}>
        {Platform.OS === 'web' ? (
          <WebCamera
            isRecording={isRecording}
            onCameraReady={handleCameraReady}
            onRecordingComplete={handleWebRecordingComplete}
          />
        ) : (
          <CameraView
            ref={cameraRef}
            style={StyleSheet.absoluteFillObject}
            facing="front"
            mode="video"
            videoQuality="720p"
            onCameraReady={handleCameraReady}
          />
        )}
      </View>

      {/* Loading */}
      {!isAllReady && (
        <View style={styles.overlay}>
          <ActivityIndicator size="large" color="#00CFFF" />
          <Text style={styles.loadingText}>Loading...</Text>
        </View>
      )}

      {/* Countdown */}
      {countdown !== null && (
        <View style={styles.overlay}>
          <Text style={styles.countdownText}>{countdown}</Text>
        </View>
      )}

      {/* Saving */}
      {isSaving && (
        <View style={styles.overlay}>
          <ActivityIndicator size="large" color="#00CFFF" />
          <Text style={styles.loadingText}>Saving your feeb...</Text>
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#000" },
  half: { flex: 1, overflow: "hidden", backgroundColor: "#000" },
  video: { flex: 1, width: screenWidth, backgroundColor: "#000" },

  debugInfo: {
    position: "absolute",
    top: 100,
    left: 10,
    right: 10,
    backgroundColor: "rgba(0, 0, 0, 0.8)",
    padding: 8,
    borderRadius: 4,
    zIndex: 1001,
  },
  debugText: {
    color: "#00FF00",
    fontSize: 10,
    fontFamily: Platform.OS === 'ios' ? 'Courier' : 'monospace',
  },

  backButton: { position: "absolute", top: 50, left: 20, zIndex: 1000 },
  backButtonCircle: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    justifyContent: "center",
    alignItems: "center",
  },
  disabledButton: { opacity: 0.5 },

  recordingIndicator: { 
    position: "absolute", 
    top: 50, 
    right: 20, 
    zIndex: 1000,
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: "rgba(0, 0, 0, 0.7)",
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 20,
  },
  redDot: { 
    width: 16, 
    height: 16, 
    borderRadius: 8, 
    backgroundColor: "#ff0000",
    marginRight: 8,
  },
  recordingText: { color: "#ff0000", fontSize: 14, fontWeight: "bold", marginRight: 8 },
  manualStopButton: { backgroundColor: "rgba(255, 0, 0, 0.8)", padding: 6, borderRadius: 15 },

  overlay: {
    ...StyleSheet.absoluteFillObject,
    backgroundColor: "rgba(0, 0, 0, 0.7)",
    justifyContent: "center",
    alignItems: "center",
    zIndex: 999,
  },
  loadingText: { color: "#fff", marginTop: 16, fontSize: 16 },
  countdownText: { fontSize: 120, color: "#fff", fontWeight: "bold", textAlign: "center" },

  permissionContainer: {
    flex: 1,
    backgroundColor: "#000",
    alignItems: "center",
    justifyContent: "center",
    padding: 20,
  },
  permissionText: { 
    marginTop: 12, 
    color: "#888", 
    textAlign: "center",
    marginBottom: 20,
  },
  permissionButton: {
    backgroundColor: "#00CFFF",
    paddingHorizontal: 20,
    paddingVertical: 12,
    borderRadius: 8,
  },
  permissionButtonText: {
    color: "#fff",
    fontSize: 16,
    fontWeight: "bold",
  },
});

// File: screens/UploadContentScreen.tsx
// screens/UploadContentScreen.tsx
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

export default function UploadContentScreen() {
  const handleUpload = () => {
    alert('Here you would pick a video from device or record new content.');
  };

  return (
    <View style={styles.container}>
      <Ionicons name="cloud-upload" size={64} color="#00CFFF" />
      <Text style={styles.title}>Upload a Video</Text>
      <Text style={styles.description}>
        Choose a video from your phone or record one to share with others.
      </Text>
      <TouchableOpacity style={styles.button} onPress={handleUpload}>
        <Text style={styles.buttonText}>Select Video</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 32,
  },
  title: {
    fontSize: 24,
    marginTop: 20,
    fontWeight: 'bold',
  },
  description: {
    marginTop: 12,
    textAlign: 'center',
    color: '#666',
  },
  button: {
    marginTop: 24,
    backgroundColor: '#00CFFF',
    paddingVertical: 14,
    paddingHorizontal: 32,
    borderRadius: 8,
  },
  buttonText: {
    color: 'white',
    fontWeight: '600',
    fontSize: 16,
  },
});


// File: screens/CreateFeebScreen.tsx
import React, { useState } from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import FeebCamera from '../components/FeebCamera';

export default function CreateFeebScreen({ navigation }: any) {
  const [showCamera, setShowCamera] = useState(false);

  if (showCamera) return <FeebCamera />;

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Record your Feeb</Text>
      <TouchableOpacity style={styles.recordButton} onPress={() => setShowCamera(true)}>
        <Ionicons name="videocam" size={36} color="white" />
      </TouchableOpacity>
      <Text style={styles.hint}>Tap to start recording your reaction</Text>
      <TouchableOpacity style={styles.backBtn} onPress={() => navigation.goBack()}>
        <Ionicons name="arrow-back" size={24} color="#00CFFF" />
        <Text style={styles.backText}>Back</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#000',
    justifyContent: 'center',
    alignItems: 'center',
  },
  title: {
    fontSize: 24,
    color: '#fff',
    marginBottom: 20,
  },
  recordButton: {
    width: 80,
    height: 80,
    borderRadius: 40,
    backgroundColor: '#00CFFF',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 10,
  },
  hint: {
    color: '#aaa',
    marginBottom: 40,
  },
  backBtn: {
    flexDirection: 'row',
    alignItems: 'center',
    position: 'absolute',
    top: 50,
    left: 20,
  },
  backText: {
    color: '#00CFFF',
    marginLeft: 6,
    fontWeight: '600',
  },
});


// File: screens/ProfileScreen.tsx
import React, { useState, useEffect, useCallback } from "react";
import {
  View,
  Text,
  StyleSheet,
  Image,
  TouchableOpacity,
  Dimensions,
  FlatList,
  Alert,
  Platform,
} from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { useFocusEffect } from "@react-navigation/native";
import { FeebStorage, Feeb } from "../utils/FeebStorage";
import SideBySidePlayer from "../components/SideBySidePlayer";

const screenWidth = Dimensions.get("window").width;
const SPACING = 8;
const COLUMN_COUNT = 2;
const ITEM_SIZE = (screenWidth - SPACING * (COLUMN_COUNT + 1)) / COLUMN_COUNT;

// User data (in real app, this would come from auth/user context)
const user = {
  avatarUri: "https://randomuser.me/api/portraits/women/44.jpg",
  name: "Lindsey Horan",
  handle: "@linHoran",
  followers: "87k",
  following: "42k",
  likes: "12.3k",
};

// Sample content data (different structure from Feeb)
interface ContentItem {
  id: string;
  uri: string;
}

const sampleContents: ContentItem[] = [
  { id: "c1", uri: "https://placekitten.com/304/304" },
  { id: "c2", uri: "https://placekitten.com/305/305" },
  { id: "c3", uri: "https://placekitten.com/306/306" },
  { id: "c4", uri: "https://placekitten.com/307/307" },
];

interface FeebItemState {
  id: string;
  displayUri: string;
  loading: boolean;
  error: boolean;
}

// Fullscreen Video Modal Component - Now using SideBySidePlayer
function FullscreenVideoModal({ 
  visible, 
  feeb, 
  onClose 
}: { 
  visible: boolean; 
  feeb: (Feeb & { displayUri?: string }) | null; 
  onClose: () => void;
}) {
  if (!visible || !feeb) return null;

  // Debug logging for SideBySidePlayer
  console.log('🎬 FullscreenVideoModal - Opening with:', {
    originalVideoUri: feeb.originalVideoUri,
    reactionVideoUri: feeb.displayUri || feeb.uri,
    feebId: feeb.id,
    isWebBlob: feeb.isWebBlob
  });

  return (
    <SideBySidePlayer
      visible={visible}
      originalVideoUri={feeb.originalVideoUri}
      reactionVideoUri={feeb.displayUri || feeb.uri}
      onClose={onClose}
      feebId={feeb.id}
      createdAt={feeb.createdAt}
      isWebBlob={feeb.isWebBlob}
    />
  );
}

// Feeb Video Component for grid
function FeebVideoGridItem({ 
  feeb, 
  displayState, 
  onPress, 
  onLongPress 
}: { 
  feeb: Feeb; 
  displayState?: FeebItemState; 
  onPress: () => void; 
  onLongPress: () => void;
}) {
  const isWebVideo = Platform.OS === 'web' && feeb.isWebBlob;
  const displayUri = displayState?.displayUri || feeb.uri;

  // Show loading state for web videos that are still loading
  if (isWebVideo && displayState?.loading) {
    return (
      <TouchableOpacity style={[styles.gridItem, styles.loadingItem]} onPress={onPress}>
        <Text style={styles.loadingText}>Loading...</Text>
      </TouchableOpacity>
    );
  }

  // Show error state for failed loads
  if (displayState?.error) {
    return (
      <TouchableOpacity 
        style={[styles.gridItem, styles.errorItem]}
        onPress={onLongPress}
        onLongPress={onLongPress}
      >
        <Ionicons name="warning" size={24} color="#ff6b6b" />
        <Text style={styles.errorText}>Invalid Video</Text>
        <Text style={styles.errorSubtext}>Tap to delete</Text>
      </TouchableOpacity>
    );
  }

  return (
    <TouchableOpacity 
      style={styles.gridItem}
      onPress={onPress}
      onLongPress={onLongPress}
      activeOpacity={0.8}
    >
      {/* Video Preview */}
      <View style={styles.videoContainer}>
        {isWebVideo && displayUri.startsWith('data:') ? (
          // For web data URLs, use video element
          <video
            src={displayUri}
            style={styles.gridVideoWeb as any}
            muted
            loop
            preload="metadata"
            onMouseEnter={(e) => {
              const video = e.target as HTMLVideoElement;
              video.currentTime = 0;
              video.play().catch(console.log);
            }}
            onMouseLeave={(e) => {
              const video = e.target as HTMLVideoElement;
              video.pause();
            }}
            onError={(e) => {
              console.error('Grid video error for feeb:', feeb.id, e);
            }}
          />
        ) : (
          // For mobile or regular URIs, use simple preview
          <View style={styles.videoPlaceholder}>
            <Ionicons name="videocam" size={32} color="#666" />
            <Text style={styles.videoPlaceholderText}>Tap to play</Text>
          </View>
        )}
      </View>

      {/* Play Button Overlay */}
      <View style={styles.playButtonOverlay}>
        <View style={styles.playButtonCircle}>
          <Ionicons name="play" size={20} color="white" />
        </View>
      </View>

      {/* Video Info Overlay */}
      <View style={styles.videoInfoOverlay}>
        <View style={styles.videoTypeIcon}>
          <Ionicons name="videocam" size={16} color="white" />
        </View>
        <Text style={styles.videoDate}>
          {new Date(feeb.createdAt).toLocaleDateString()}
        </Text>
        {isWebVideo && (
          <Text style={styles.videoPlatform}>Web</Text>
        )}
      </View>
    </TouchableOpacity>
  );
}

export default function ProfileScreen() {
  const [activeTab, setActiveTab] = useState<"Feebs" | "Contents">("Feebs");
  const [userFeebs, setUserFeebs] = useState<Feeb[]>([]);
  const [feebDisplayStates, setFeebDisplayStates] = useState<FeebItemState[]>([]);
  const [loading, setLoading] = useState(true);
  const [fullscreenFeeb, setFullscreenFeeb] = useState<(Feeb & { displayUri?: string }) | null>(null);

  // DEBUG FUNCTION - Check what's actually being saved
  const debugFeebFiles = async () => {
    console.log('🔍 ======= FEEB DEBUG START =======');
    
    try {
      const feebs = await FeebStorage.getAllFeebs();
      console.log(`🔍 Found ${feebs.length} feebs`);
      
      for (let i = 0; i < feebs.length; i++) {
        const feeb = feebs[i];
        console.log(`🔍 FEEB ${i + 1}:`, {
          id: feeb.id,
          uri: feeb.uri,
          originalVideoUri: feeb.originalVideoUri,
          isWebBlob: feeb.isWebBlob,
          createdAt: feeb.createdAt
        });
        
        // Check if it's a web blob
        if (Platform.OS === 'web' && feeb.isWebBlob) {
          try {
            console.log('🔍 Getting display URI for web feeb...');
            const displayUri = await FeebStorage.getFeebDisplayUri(feeb);
            
            if (displayUri) {
              console.log('🔍 Display URI: SUCCESS');
              console.log('🔍 URI length:', displayUri.length);
              console.log('🔍 URI starts with:', displayUri.substring(0, 50));
              console.log('🔍 URI type:', displayUri.startsWith('data:') ? 'DATA_URL' : 'OTHER');
            } else {
              console.log('🔍 Display URI: FAILED - empty or null');
            }
          } catch (error) {
            console.log('🔍 Error getting display URI:', error);
          }
        }
        
        console.log('🔍 -------------------------');
      }
      
      Alert.alert(
        'Debug Info', 
        `Found ${feebs.length} feebs. Check console for details.`
      );
      
    } catch (error) {
      console.error('🔍 Error in debug:', error);
      Alert.alert('Debug Error', error.message);
    }
    
    console.log('🔍 ======= FEEB DEBUG END =======');
  };

  // Load feebs when screen comes into focus
  useFocusEffect(
    useCallback(() => {
      loadUserFeebs();
    }, [])
  );

  const loadUserFeebs = async () => {
    try {
      setLoading(true);
      const feebs = await FeebStorage.getAllFeebs();
      setUserFeebs(feebs);
      console.log(`📱 Loaded ${feebs.length} feebs from storage`);
      
      // Load display URIs for web feebs
      await loadFeebDisplayUris(feebs);
    } catch (error) {
      console.error("Error loading feebs:", error);
      Alert.alert("Error", "Failed to load your feebs");
    } finally {
      setLoading(false);
    }
  };

  const loadFeebDisplayUris = async (feebs: Feeb[]) => {
    console.log('🖼️ Loading display URIs for feebs...');
    
    const displayStates: FeebItemState[] = await Promise.all(
      feebs.map(async (feeb) => {
        const state: FeebItemState = {
          id: feeb.id,
          displayUri: feeb.uri,
          loading: false,
          error: false
        };

        try {
          if (Platform.OS === 'web' && feeb.isWebBlob) {
            console.log(`🔍 Loading display URI for web feeb: ${feeb.id}`);
            state.loading = true;
            
            const displayUri = await FeebStorage.getFeebDisplayUri(feeb);
            state.loading = false;
            
            if (displayUri && displayUri.length > 0) {
              state.displayUri = displayUri;
              console.log(`✅ Display URI loaded for ${feeb.id}: Success`);
            } else {
              console.log(`❌ Display URI failed for ${feeb.id}: Empty or invalid`);
              state.error = true;
              state.displayUri = '';
            }
          }
        } catch (error) {
          console.error(`❌ Error loading display URI for feeb ${feeb.id}:`, error);
          state.error = true;
          state.loading = false;
          state.displayUri = '';
        }

        return state;
      })
    );

    setFeebDisplayStates(displayStates);
  };

  const getFeebDisplayState = (feebId: string): FeebItemState | undefined => {
    return feebDisplayStates.find(state => state.id === feebId);
  };

  const handlePlayFeeb = async (feeb: Feeb) => {
    try {
      console.log('🎬 Playing feeb:', feeb.id);
      
      let playableUri = feeb.uri;
      
      // For web videos, get the display URI
      if (Platform.OS === 'web' && feeb.isWebBlob) {
        const displayState = getFeebDisplayState(feeb.id);
        if (displayState?.displayUri) {
          playableUri = displayState.displayUri;
        } else {
          console.log('Loading display URI for playback...');
          playableUri = await FeebStorage.getFeebDisplayUri(feeb);
        }
      }
      
      if (!playableUri) {
        Alert.alert('Error', 'Video could not be loaded');
        return;
      }
      
      console.log('🎬 Setting fullscreen feeb with URIs:', {
        originalVideoUri: feeb.originalVideoUri,
        reactionVideoUri: playableUri
      });
      
      setFullscreenFeeb({
        ...feeb,
        displayUri: playableUri
      });
      
    } catch (error) {
      console.error('Error playing feeb:', error);
      Alert.alert('Error', 'Failed to play video');
    }
  };

  const handleDeleteFeeb = async (feebId: string) => {
    Alert.alert(
      "Delete Feeb",
      "Are you sure you want to delete this feeb?",
      [
        { text: "Cancel", style: "cancel" },
        {
          text: "Delete",
          style: "destructive",
          onPress: async () => {
            try {
              await FeebStorage.deleteFeeb(feebId);
              await loadUserFeebs(); // Reload the list
              Alert.alert("Success", "Feeb deleted successfully");
            } catch (error) {
              console.error("Error deleting feeb:", error);
              Alert.alert("Error", "Failed to delete feeb");
            }
          },
        },
      ]
    );
  };

  const handleCleanupInvalidFeebs = async () => {
    Alert.alert(
      "Clean Up Invalid Videos",
      "This will remove feebs that can no longer be displayed. Continue?",
      [
        { text: "Cancel", style: "cancel" },
        {
          text: "Clean Up",
          style: "destructive",
          onPress: async () => {
            try {
              const invalidFeebIds = feebDisplayStates
                .filter(state => state.error)
                .map(state => state.id);
              
              for (const feebId of invalidFeebIds) {
                await FeebStorage.deleteFeeb(feebId);
              }
              
              await loadUserFeebs(); // Reload the list
              Alert.alert("Success", `Cleaned up ${invalidFeebIds.length} invalid feebs`);
            } catch (error) {
              console.error("Error cleaning up feebs:", error);
              Alert.alert("Error", "Failed to clean up feebs");
            }
          },
        },
      ]
    );
  };

  const renderFeebItem = ({ item }: { item: Feeb }) => {
    const displayState = getFeebDisplayState(item.id);
    
    return (
      <FeebVideoGridItem
        feeb={item}
        displayState={displayState}
        onPress={() => handlePlayFeeb(item)}
        onLongPress={() => handleDeleteFeeb(item.id)}
      />
    );
  };

  const renderContentItem = ({ item }: { item: ContentItem }) => (
    <View style={styles.gridItem}>
      <Image 
        source={{ uri: item.uri }} 
        style={styles.gridImage}
        resizeMode="cover"
      />
      <View style={styles.playIcon}>
        <Ionicons name="play-circle" size={24} color="white" />
      </View>
    </View>
  );

  const renderHeader = () => (
    <View style={styles.headerContainer}>
      <Text style={styles.title}>My profile</Text>
      
      {/* User Avatar */}
      <Image 
        source={{ uri: user.avatarUri }} 
        style={styles.avatar}
        resizeMode="cover"
      />
      <Text style={styles.name}>{user.name}</Text>
      <Text style={styles.handle}>{user.handle}</Text>

      {/* Stats Row */}
      <View style={styles.statsRow}>
        <View style={styles.stat}>
          <Text style={styles.statValue}>{user.followers}</Text>
          <Text style={styles.statLabel}>Followers</Text>
        </View>
        <View style={styles.stat}>
          <Text style={styles.statValue}>{user.following}</Text>
          <Text style={styles.statLabel}>Following</Text>
        </View>
        <View style={styles.stat}>
          <Text style={styles.statValue}>{userFeebs.length}</Text>
          <Text style={styles.statLabel}>Feebs</Text>
        </View>
      </View>

      {/* Edit Button */}
      <TouchableOpacity style={styles.editButton}>
        <Text style={styles.editButtonText}>Edit profile</Text>
        <Ionicons name="pencil" size={20} color="#00CFFF" />
      </TouchableOpacity>

      {/* DEBUG BUTTON */}
      <Touch